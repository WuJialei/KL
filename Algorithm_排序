1.基础知识
1.1.排序基础讲解：https://juejin.im/post/5b95da8a5188255c775d8124#comment
1.2.快排时间复杂度分析：https://blog.csdn.net/weshjiness/article/details/8660583

2.应用
2.1.基础应用
2.1.1.奇偶平均分组，不消耗内存（leetcode [922] Sort Array By Parity II）
  代码：
  class Solution {
      public int[] sortArrayByParityII(int[] A) {
          int j = 1;
          for (int i = 0; i < A.length; i += 2) {
              if (A[i] % 2 == 1) {
                  while (A[j] % 2 == 1) {
                      j += 2;
                  }
                  int temp = A[i];
                  A[i] = A[j];
                  A[j] = temp;
              }
          }
          return A;
          /*
          int[] odds = new int[A.length/2];
          int[] evens = new int[A.length/2];
          int o = 0, e = 0;
          for (int a : A) {
              if ((a%2) == 0) {
                  evens[e++] = a;
              } else {
                  odds[o++] = a;
              }
          }
          int[] ans = new int[A.length];
          for (int i = 0; i < A.length/2; i++) {
              ans[i*2] = evens[i];
              ans[i*2+1] = odds[i];
          }
          return ans;
          */
      }
  }
  
  2.1.2.双指针（leetcode [349] Intersection of Two Arrays）
    代码：
    class Solution {
      public int[] intersection(int[] nums1, int[] nums2) {
          Arrays.sort(nums1);
          Arrays.sort(nums2);
          HashSet<Integer> set = new HashSet<Integer>();
          int i = 0, j = 0;
          while (i < nums1.length && j < nums2.length) {
              if (nums1[i] == nums2[j]) {
                  set.add(nums1[i]);
                  ++i;
                  ++j;
              } else if (nums1[i] < nums2[j]) {
                  ++i;
              } else {
                  ++j;
              }
          }
          int[] ans = new int[set.size()];
          int cnt = 0;
          for (int num : set) {
              ans[cnt++] = num;
          }
          return ans;
          /*
          HashSet<Integer> set1 = new HashSet<Integer>();
          HashSet<Integer> set2 = new HashSet<Integer>();
          for (int num : nums1) {
              set1.add(num);
          }
          for (int num : nums2) {
              set2.add(num);
          }
          ArrayList<Integer> list = new ArrayList<>();
          for (int num : set1){
              if (set2.contains(num)) {
                  list.add(num);
              }
          }
          int[] ans = new int[list.size()];
          int cnt = 0;
          for (int num : list) {
              ans[cnt++] = num;
          }
          return ans;
          */
      }
  }
使用哈希映射解决类似（不用排序，leetcode [350] Intersection of Two Arrays II）
  代码：
  class Solution {
      public int[] intersect(int[] nums1, int[] nums2) {
          if (nums1.length > nums2.length) {
              return intersect(nums2, nums1);
          }
          // 哈希映射
          HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
          for (int num : nums1) {
              map.put(num, map.getOrDefault(num, 0) + 1);
          }
          int cnt = 0, len = nums1.length;
          for (int num : nums2) {
              if (cnt >= len) {
                  break;
              }
              int t = map.getOrDefault(num, 0);
              if (t > 0) {
                  nums1[cnt++] = num;
                  map.put(num, t-1);
              }
          }
          return Arrays.copyOfRange(nums1, 0, cnt);
      }
  }
  
2.1.3.二维有序矩阵寻找指定值（leetcode [240] Search a 2D Matrix II）
  代码：
  class Solution {
      public boolean searchMatrix(int[][] matrix, int target) {
          if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
              return false;
          }
          return search(matrix, target, 0, matrix[0].length - 1);
      }

      public boolean search (int[][] matrix, int target, int row, int col) {
          if (row >= matrix.length || col < 0) {
              return false;
          }
          if (matrix[row][col] == target) {
              return true;
          } else if (matrix[row][col] > target) {
              return search(matrix, target, row, col-1);
          } else {
              return search(matrix, target, row+1, col);
          }
      }

  }
2.2.归并排序（leetcode 1305. All Elements in Two Binary Search Trees）
  代码：
  import java.util.ArrayList;
  import java.util.List;

  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  class Solution {

        public void inOrder (TreeNode node, List<Integer> list) {
            if (node == null) {
                return;
            }
            inOrder(node.left, list);
            list.add(node.val);
            inOrder(node.right, list);
        }

      public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
          List<Integer> list1 = new ArrayList<>();
          List<Integer> list2 = new ArrayList<>();
          inOrder(root1, list1);
          inOrder(root2, list2);
          List<Integer> ans = new ArrayList<>();
          int i = 0, j = 0;
          while (i < list1.size() && j < list2.size()) {
              int a = list1.get(i);
              int b = list2.get(j);
              if (a < b) {
                  ans.add(a);
                  ++i;
              } else {
                  ans.add(b);
                  ++j;
              }
          }
          while (i < list1.size()) {
              ans.add(list1.get(i++));
          }
          while (j < list2.size()) {
              ans.add(list2.get(j++));
          }
          return ans;
      }
  }

2.3.选择排序变体(leetcode [969] Pancake Sorting)
  思路:
  找出最大元素，部分翻转将该最大元素至链表头部，全翻转将链表头部元素到最后，相当于每一步都是找最大元素然后翻转到最后；
  代码:
  class Solution {

      public int maxIndex (List<Integer> list) {
          int index = 0;
          for (int i = 1; i < list.size(); ++i) {
              if (list.get(i) > list.get(index)) {
                  index = i;
              }
          }
          return index;
      }

      public List<Integer> pancakeSort(int[] A) {
          List<Integer> list = new ArrayList<>();
          for (int a : A) {
              list.add(a);
          }
          List<Integer> ans = new ArrayList<>();
          for (int i = A.length - 1; i > 0; --i) {
              int j = maxIndex(list);
              if (j == i) {
                  list.remove(j);
              } else {
                  if (j > 0) {
                      List<Integer> list1 = list.subList(0, j+1);
                      List<Integer> list2 = list.subList(j+1, i+1);
                      ans.add(j+1);
                      Collections.reverse(list1);
                      list = new ArrayList<>();
                      list.addAll(list1);
                      list.addAll(list2);
                  }
                  Collections.reverse(list);
                  ans.add(i+1);
                  list.remove(i);
              }
          }
          return ans;
      }
  }
  
2.4.堆排序（leetcode [973] K Closest Points to Origin）
  代码：
  class Solution {

      public int squre (int a, int b) {
          return a * a + b * b;
      }

      public int[][] kClosest(int[][] points, int K) {
          PriorityQueue<int[]> queue = new PriorityQueue<>(K, (o2, o1) -> o1[0] * o1[0] + o1[1] * o1[1] - o2[0] * o2[0] - o2[1] * o2[1]);

          for (int i = 0; i < points.length; ++i) {
              if (queue.size() < K) {
                  queue.offer(points[i]);
              } else if (squre(points[i][0], points[i][1]) < squre(queue.peek()[0], queue.peek()[1])) {
                  queue.poll();
                  queue.offer(points[i]);
              }
          }
          int[][] ans = new int[K][2];
          int cnt = 0;
          while(!queue.isEmpty()) {
              ans[cnt] = queue.poll();
              ++cnt;
          }
          return ans;
      }
  }
  
  2.5.java集合排序（Collections.sort()结合lambda表达式的写法）
  2.5.1.查找字典里最匹配的字符串（leetcode [524] Longest Word in Dictionary through Deleting）
    代码：
    class Solution {

      String s;

      public boolean find (String str) {
          int index = 0;
          int len = s.length();
          int cnt = 0;
          for (; cnt < str.length();) {
              if (index >= len) {
                  break;
              }
              if (str.charAt(cnt) == s.charAt(index)) {
                  ++cnt;
                  ++index;
              } else {
                  ++index;
              }
          }
          return cnt == str.length();
      }

      public String findLongestWord(String s, List<String> d) {
          this.s = s;
          List<String> list = new ArrayList<String>();
          for (String str : d) {
              if (find(str)) {
                  if (list.size() == 0) {
                      list.add(str);
                  } else {
                      if (str.length() == list.get(0).length()) {
                          list.add(str);
                      } else if (str.length() > list.get(0).length()) {
                          list = new ArrayList<String>();
                          list.add(str);
                      }
                  }

              }
          }
          if (list.size() == 0) {
              return "";
          } else {
              if (list.size() > 1) {
                  Collections.sort(list, (a, b) -> a.compareTo(b));
              }            
              return list.get(0);
          }

      }
  }

  
  
