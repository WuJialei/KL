1.基本知识
1.1.树的基本概念：https://blog.csdn.net/csdn_aiyang/article/details/84977814
1.2.树的基本算法：cnblogs.com/maybe2030/p/4732377.html
1.3.二叉树的基本算法：https://juejin.im/entry/585b8660128fe1006ddbd45d

2.BST(Binary Sort Tree) 二叉搜索/排序/查找树
2.1.基本点
二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
　　1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
　　2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
　　3) 左、右子树也分别为二叉排序树；
　　4) 没有键值相等的节点。
  二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。
  二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。
原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。
  二叉查找树的高度决定了二叉查找树的查找效率。
  BST的插入、删除、遍历及其他相关概念参考cnblogs.com/maybe2030/p/4732377.html BST部分。
2.2.BST的遍历
2.2.1.二叉搜索树的范围和（leetcode [938] Range Sum of BST）
  基本思路：
  二叉搜索树的中序遍历是升序，其范围即为取排序后的两个范围和
  代码：
  class Solution {

      int ans;

      public int rangeSumBST(TreeNode root, int L, int R) {
          ans = 0;
          dfs(root, L, R);
          return ans;
      }

      public void dfs (TreeNode node, int l, int r) {
          if (node == null) {
              return;
          }

          if (node.val >= l && node.val <= r) {
              ans += node.val;
          }
          // 要不要走左子树
          if (node.val > l) {
              dfs (node.left, l, r);
          }
          // 要不要走右子树
          if (node.val < r) {
              dfs (node.right, l, r);
          }
      }

  }
  2.2.2.二叉搜索树的查找（leetcode [700] Search in a Binary Search Tree）
    代码：（递归/迭代）
    class Solution {
        public TreeNode searchBST(TreeNode root, int val) {
            // TreeNode ret = dfs (root, val);
            TreeNode ret = null;
            if (root == null) {
                return null;
            }
            while (root != null) {
                if (root.val == val) {
                    ret = root;
                    break;
                }else if (val < root.val) {
                    root = root.left;
                } else if (val > root.val) {
                    root = root.right;
                }            
            }
            return ret;
        }

        public TreeNode dfs (TreeNode node, int val) {
            if (node == null) {
                return null;
            }
            if (node.val == val) {
                return node;
            } else if (val < node.val) {
                return dfs(node.left, val);
            } else {
                return dfs(node.right, val);
            }
        }

    }
  2.2.3.二叉搜索树的修剪（leetcode [669] Trim a Binary Search Tree）
    代码：
    class Solution {

        public TreeNode trimBST(TreeNode root, int L, int R) {

            if (root == null) {
                return null;
            }
            if (root.val < L) {
                return trimBST(root.right, L, R);
            }
            if (root.val > R) {
                return trimBST(root.left, L, R);
            }
            root.left = trimBST(root.left, L, R);
            root.right = trimBST(root.right, L, R);
            return root;

        }

    }
2.2.4.二叉搜索树的中序遍历是递增数组（leetcode [653] Two Sum IV - Input is a BST）
  代码：
  class Solution {

      List<Integer> list;
      int k;
      public boolean findTarget(TreeNode root, int k) {
          list = new ArrayList<Integer>();
          this.k = k;
          order(root);
          return dfs(0, list.size() - 1);
      }

      public void order(TreeNode node) {
          if (node == null) {
              return;
          }
          order(node.left);
          list.add(node.val);
          order(node.right);
      }

      public boolean dfs (int start, int end) {
          if (start >= end) {
              return false;
          }
          if (list.get(start) + list.get(end) == k) {
              return true;
          } else if (list.get(start) + list.get(end) < k) {
              return dfs (start + 1, end);
          } else {
              return dfs (start, end - 1);
          }
      }

  }
2.2.5.二叉搜索树比该节点值大的累加和（leetcode [538] Convert BST to Greater Tree）
  代码：
  class Solution {

      int sum = 0;

      public TreeNode convertBST(TreeNode root) {
          if (root == null) {
              return null;
          }
          // dfs先右后左，右到底才会渐渐从底层往左
          convertBST(root.right);
          root.val += sum;
          sum = root.val;
          convertBST(root.left);
          return root;
      }

  }
    
  3.N叉树
  3.1.N叉树的前序遍历（leetcode [589] N-ary Tree Preorder Traversal）
    代码：
    class Solution {

        List<Integer> ans;

        public List<Integer> preorder(Node root) {
            ans = new ArrayList<Integer>();
            // dfs(root);
            Stack<Node> stack = new Stack<Node>();
            if (root == null) {
                return ans;
            }

            stack.push(root);
            while (!stack.isEmpty()) {
                Node node = stack.pop();
                ans.add(node.val);
                if (node.children != null) {
                    for (int i = node.children.size() - 1; i >= 0; --i) {
                        stack.push(node.children.get(i));
                    }
                }
            }
            return ans;
        }

        public void dfs(Node node) {
            if (node == null) {
                return;
            }
            ans.add(node.val);
            if (node.children != null) {
                for (Node child : node.children) {
                    dfs(child);
                }
            }
        }

    }
3.2.N叉树的后序遍历（leetcode [590] N-ary Tree Postorder Traversal）
  代码：
  class Solution {

      List<Integer> ans;

      public List<Integer> postorder(Node root) {
          ans = new ArrayList<Integer>();
          // dfs(root);
          if (root == null) {
              return ans;
          }
          Stack<Node> stack = new Stack<Node>();
          stack.push(root);
          while (!stack.isEmpty()) {
              Node node = stack.pop();
              ans.add(0, node.val);
              if (node.children != null) {
                  for (Node child : node.children) {
                      stack.push(child);
                  }
              }
          }
          return ans;
      }

      public void dfs(Node node) {
          if (node == null) {
              return;
          }
          if (node.children != null) {
              for (Node child : node.children) {
                  dfs(child);
              }
          }
          ans.add(node.val);
      }

  }
  3.4.N叉树树的深度（leetcode [559] Maximum Depth of N-ary Tree）
    代码：
    class Solution {
        public int maxDepth(Node root) {
            return depth(root);
        }

        public int depth(Node node) {
            if (node == null) {
                return 0;
            } else if (node.children == null) {
                return 1;
            } else {
                int ans = 0;
                for (Node child : node.children) {
                    ans = Math.max(ans, depth(child));
                }
                return ans + 1;
            }

        }

    }
  二叉树的深度（leetcode [104] Maximum Depth of Binary Tree）
    代码：
    class Solution {
        public int maxDepth(TreeNode root) {
            if (root == null) {
                return 0;
            }
            return dfs(root);
        }

        public int dfs(TreeNode node){
            if (node == null) {
                return 0;
            } else if (node.left == null && node.right == null) {
                return 1;
            } else {
                return 1 + Math.max(dfs(node.left), dfs(node.right));
            }
        }

    }
    
4.二叉树
4.1.二叉树的遍历（leetcode  [1022] Sum of Root To Leaf Binary Numbers）
  代码：
  class Solution {
        int sum;
        public int sumRootToLeaf(TreeNode root) {
            sum = 0;
            dfs(root, 0);
            return sum;
        }

        public void dfs (TreeNode node, int cntSum) {
            if (node == null) {
                return;
            } else if (node.left == null && node.right == null) {
                sum += cntSum * 2 + node.val;
                return;
            } else {
                dfs(node.left, cntSum * 2 + node.val);
                dfs(node.right, cntSum * 2 + node.val);
            }
        }
    }
  4.2.二叉树的翻转（leetcode [226] Invert Binary Tree）
    代码：（递归/迭代）
    class Solution {
        public TreeNode invertTree(TreeNode root) {
            if(root == null) {
                return null;
            }
            /*
            // 递归
            TreeNode l = root.left;
            TreeNode r = root.right;
            root.left = invertTree(r);
            root.right = invertTree(l);
            return root;
            */

            // 迭代
            Queue<TreeNode> queue = new LinkedList<TreeNode>();
            queue.offer(root);
            while (!queue.isEmpty()) {
                TreeNode node = queue.poll();
                TreeNode tmp = node.left;
                node.left = node.right;
                node.right = tmp;
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            return root;

        }
    }
  4.3.二叉树各层的平均值（leetcode [637] Average of Levels in Binary Tree）
    代码：（BFS）
    class Solution {

        Queue<TreeNode> queue;

        public List<Double> averageOfLevels(TreeNode root) {
            queue = new LinkedList<TreeNode>();
            List<Double> list = new ArrayList<Double>();
            if (root == null) {
                return list;
            }
            queue.offer(root);
            while (!queue.isEmpty()) {
                Queue<TreeNode> tmp = new LinkedList<TreeNode>();
                int cnt = 0;
                double sum = 0;
                while(!queue.isEmpty()) {
                    TreeNode node = queue.poll();
                    ++cnt;
                    sum += node.val;
                    if (node.left != null) {
                        tmp.offer(node.left);
                    }
                    if (node.right != null) {
                        tmp.offer(node.right);
                    }
                }
                list.add(sum/cnt);
                queue = tmp;
            }
            return list;
        }
    }
    
5.平衡二叉树(Balanced Binary Tree又被称为AVL树，AVL树是最先发明的自平衡二叉查找树,且具有以下性质：
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。很好的解决了
二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁
旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。)
5.1.平衡二叉树的建立
5.1.1.有序数组转化为平衡二叉树（leetcode [108] Convert Sorted Array to Binary Search Tree）
  代码：（二分）
  class Solution {
      public TreeNode sortedArrayToBST(int[] nums) {
          return bs(nums, 0, nums.length-1);
      }

      public TreeNode bs(int[] arrays, int start, int end) {
          if (start > end) {
              return null;
          }
          int mid = start + (end - start)/2;
          TreeNode node = new TreeNode(arrays[mid]);
          node.left = bs(arrays, start, mid - 1);
          node.right = bs(arrays, mid + 1, end);
          return node;
      }

  }


