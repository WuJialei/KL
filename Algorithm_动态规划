1.基础知识
1.1.基础：https://juejin.im/post/5d1418a5e51d45108c59a57c#heading-2
1.2.背包九讲：https://www.kancloud.cn/kancloud/pack/70125
1.3.背包九讲java实现：https://www.zhihu.com/people/liu-xun-39-54/posts
1.4.最长公共子序列和最长公共子串(最长共同子序列)：https://www.cnblogs.com/en-heng/p/3963803.html

2.1.数
2.1.1.除数博弈（leetcode [1025] Divisor Game）
  代码：
  class Solution {
      public boolean divisorGame(int N) {
          // 最优的数不是最大的约数，而是能找到的让自己立于不败之地的最合适的数
          if (N <= 1) {
              return false;
          }
          boolean[] dp = new boolean[N+1];
          dp[1] = false;
          dp[2] = true;
          for (int i = 3; i <= N; ++i) {
              for (int j = 1; j < i; ++j) {
                  if (i%j==0 && !dp[i-j]) {
                      dp[i] = true;
                      break;
                  }
              }
          }
          return dp[N];
      }

  }
2.1.2.数的比特位1的个数（leetcode [338] Counting Bits）
  代码：
  class Solution {
      public int[] countBits(int num) {
          int[] dp = new int[num + 1];
          dp[0] = 0;
          if (num >= 1) {
              dp[1] = 1;
              for (int i = 2; i <= num; ++i) {
                  dp[i] = dp[i >> 1] + (i&1);
              }
          }
          return dp;
      }
  }
2.1.3.飞机座位分配概率（leetcode [1227] Airplane Seat Assignment Probability）
  代码：
  class Solution {
      public double nthPersonGetsNthSeat(int n) {
          if (n == 1) {
              return 1.0;
          }
          double sums = 1.0;
          double ans = sums;
          // f(n) = 1/n{f(1) + f(2) + ... + f(n-1)}
          for (int i = 2; i <= n; ++i) {
              ans = (1.0/(double)i) * sums;
              sums += ans;
          }
          return ans;
      }
  }
2.1.4.二叉搜索树的个数（leetcode [96] Unique Binary Search Trees）
  代码：
  class Solution {

      boolean[] flags;

      public int numTrees(int n) {
          if (n <= 1) {
              return 1;
          }
          /*
          G(n): 长度为n的序列的不同二叉搜索树个数。
          F(i,n): 以i为根的不同二叉搜索树个数。
          链接：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/
          */
          int[] dp = new int[n+1];
          dp[0] = 1;
          dp[1] = 1;
          for (int i = 2; i <= n; ++i) {
              for (int j = 1; j <= i; ++j) {
                  dp[i] += dp[j-1] * dp[i-j];
              }
          }
          return dp[n];
          /*
          flags = new boolean[n+1];
          int ans = 0;
          for (int i = 1; i <= n; ++i) {
              flags[i] = true;
              ans += dfs(i, 1, n);
              flags[i] = false;
          }
          return ans;
          */
      }

      public int dfs (int index, int start, int end) {
          if (start > end) {
              return 0;
          }
          if (start == end) {
              return 1;
          }
          int left = 0;
          for (int next = start; next < index; ++next) {
              if (!flags[next]) {
                  flags[next] = true;
                  left += dfs(next, start, index-1);
                  flags[next] = false;
              }
          }
          int right = 0;
          for (int next = index+1; next <= end; ++next) {
              if (!flags[next]) {
                  flags[next] = true;
                  right += dfs(next, index+1, end);
                  flags[next] = false;
              }
          }
          return (left == 0 || right == 0) ? Math.max(left, right) : left * right;
      }


  }
2.1.5.数拆解求最大乘积（leetcode [343] Integer Break）
  代码：
  class Solution {
      public int integerBreak(int n) {
          int[] dp = new int[n+1];
          dp[1] = 1;
          dp[2] = 1;
          // 遍历，然后按需不需要拆解
          // dp[i] = max{j*dp[i-j], j*(i-j)}
          for (int i = 3; i <= n; ++i) {
              for (int j = 1; j < i; ++j) {
                  dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)));
              }
          }
          return dp[n];
      }
  }
2.1.6.掷骰子求点数和（leetcode [1155] Number of Dice Rolls With Target Sum）
  代码：
  class Solution {
      public int numRollsToTarget(int d, int f, int target) {
          int MOD = 1000000007;
          int[][] dp = new int[2][target+1];
          for (int i = 1; i <= Math.min(target, f); ++i) {
              dp[1][i] = 1;
          }
          // dp[i][j]表示i次摇筛子的和为j
          // dp[i][j] = dp[i-1][j-k], 1 <= k <= j, 第i次摇到的筛子数是k
          for (int i = 2; i <= d; ++i) {
              int index = i & 1;
              for (int j = 1; j <= target; ++j) {
                  dp[index][j] = 0;
                  for (int k = 1; k <= Math.min(j, f); ++k) {
                      dp[index][j] = (dp[index][j] + dp[1-index][j-k]) % MOD;
                  }
              }
          }
          return dp[d&1][target];
      }
  }
2.1.7.只有两个键键盘的粘贴复制次数（leetcode 650. 2 Keys Keyboard）
  代码：
  class Solution {
      public int minSteps(int n) {
          int[] dp = new int[n+1];
          dp[1] = 0;
          for (int i = 2; i <= n; ++i) {
              // 最坏情况
              dp[i] = i;
              for (int j = 2; j < i/2; ++j) {
                  if (i % j == 0) {
                      dp[i] = Math.min(dp[i], dp[j] + 1 + i/j - 1);
                  }
              }
          }
          return dp[n];
      }
  }
2.1.8.计算各个位数不同的数字（leetcode [357] Count Numbers with Unique Digits）
  代码：
  class Solution {
      public int countNumbersWithUniqueDigits(int n) {
          int[] dp = new int[11];
          dp[0] = 1;
          dp[1] = 10;
          for (int i = 2; i <= 10; ++i) {
              int temp = 9;
              for (int cnt = 9; cnt >= 11-i; --cnt) {
                  temp *= cnt;
              }
              dp[i] = dp[i-1] + temp;
          }
          if (n <= 10) {
              return dp[n];
          } else {
              return dp[10];
          }
      }
  }
2.1.9.斐波那契数列变体之最长的斐波那契数列（leetcode [873] Length of Longest Fibonacci Subsequence）
  代码：
  class Solution {

      public int lenLongestFibSubseq(int[] A) {
          int n = A.length;
          HashMap<Integer, Integer> index = new HashMap<>();
          for (int i = 0; i < n; ++i) {
              index.put(A[i], i);
          }
          int ans = 0;
          HashMap<Integer, Integer> dp = new HashMap<>();
          for (int k = 0; k < n; ++k) {
              for (int j = k-1; j > 0; --j) {
                  int i = index.getOrDefault(A[k]-A[j], -1);
                  if (i >= 0 && i < j) {
                      int temp = dp.getOrDefault(i*n + j, 2) + 1;
                      dp.put(j*n + k, temp);
                      ans = Math.max(ans, temp);
                  }
              }
          }
          if (ans < 3) {
              return 0;
          } else {
              return ans;
          }
      }
  }
变体，斐波那契数列变体之记忆化dfs（leetcode [688] Knight Probability in Chessboard）
  代码：
  class Solution {

      int[][] directions = {{1, 2}, {2, 1},{2, -1}, {1, -2},{-1, 2}, {-2, 1},{-2, -1}, {-1, -2}};
      double[][] board;
      int n;

      public boolean judge (int x, int y) {
          if (x < 1 || x > n || y < 1 || y > n) {
              return false;
          }
          return true;
      }

      public double knightProbability(int N, int K, int r, int c) {
          if (K == 0) {
              return (double)1;
          }
          n = N;
          int k = K;
          double[][] dp = new double[2][(n+1)*(n+1)];
          // dp[i,j,k]表示坐标i，j迭代k次在盘内的概率
          // dp[i,j,k] = sum(dp[ii,jj,k-1]/8.0), ii, jj为i,j的下一步范围内坐标
          for (int i = 1; i <= n; ++i) {
              for (int j = 1; j <= n; ++j) {
                  double temp = 0;
                  for (int cnt = 0; cnt < directions.length; ++cnt) {
                      if (judge(i+directions[cnt][0], j + directions[cnt][1])) {
                          temp += 1.0/8;
                      }
                  }
                  dp[1][i*(n+1) + j] = temp;
              }
          }
          for (int t = 2; t <= k; ++t) {
              int index = t & 1;
              for (int i = 1; i <= n; ++i) {
                  for (int j = 1; j <= n; ++j) {
                      double temp = 0;
                      for (int cnt = 0; cnt < directions.length; ++cnt) {
                          if (judge(i+directions[cnt][0], j + directions[cnt][1])) {
                              int ii = i+directions[cnt][0];
                              int jj = j + directions[cnt][1];
                              temp += dp[1-index][ii*(n+1) + jj]/8;
                          }
                      }
                      dp[index][i*(n+1) + j] = temp;
                  }
              }
          }
          return dp[k&1][(r+1)*(n+1) + c +1];
          /*
          board = new double[N+1][N+1];
          for (int i = 1; i <= n; ++i) {
              for (int j = 1; j <= n; ++j) {
                  double temp = 0;
                  for (int cnt = 0; cnt < directions.length; ++cnt) {
                      if (judge(i+directions[cnt][0], j + directions[cnt][1])) {
                          temp += 1.0/8;
                      }
                  }
                  board[i][j] = temp;
              }
          }
          double ans = 0;
          ans = dfs(r+1, c+1, K);
          return ans;
          */
      }

      public double dfs (int x, int y, int k) {
          if (k == 1) {
              return board[x][y];
          }
          double ret = 0;
          for (int i = 0; i < directions.length; ++i) {
              if (judge(x+directions[i][0], y+directions[i][1])) {
                  ret += 1.0/8 * dfs(x+directions[i][0], y+directions[i][1], k-1);
              }
          }
          return ret;
      }

  }
变体之记忆化优化dfs，多边形的三角形顶点的乘积和（leetcode [1039] Minimum Score Triangulation of Polygon）
  代码：
  class Solution {

      int[] points;
      int[][] dp;

      public int minScoreTriangulation(int[] A) {
          points = A;
          int n = A.length;
          dp = new int[n][n];
          for (int[] temp : dp) {
              Arrays.fill(temp, -1);
          }
          // dp[i][j] 表示从i到j的最小三角形乘积和
          // 记忆化优化dfs
          return dfs(0, n-1);
      }

      public int dfs (int left, int right) {
          int ans = Integer.MAX_VALUE;
          if (left + 1 == right) {
              return dp[left][right] = 0;
          }
          if (dp[left][right] != -1) {
              return dp[left][right];
          }
          for (int k = left + 1; k < right; ++k) {
              ans = Math.min(ans, dfs(left, k) + dfs(k, right) + points[left] * points[right] * points[k]);
          }
          return dp[left][right] = ans;
      }

  }

2.2.股票买卖
2.2.1.股票只能买卖一次（leetcode [121] Best Time to Buy and Sell Stock）
  思路：在价格曲线图中，纵轴差值的绝对值表示盈利或者亏本的金额，买卖一次，最大利润即为找盈利情况下的最大差值
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int maxProfit = 0;
          int minPrice = prices[0];
          for (int i = 1; i < prices.length; ++i) {
              int tempProfit = prices[i] - minPrice > 0 ? prices[i] - minPrice : 0;
              maxProfit = Math.max(maxProfit, tempProfit);
              minPrice = Math.min(minPrice, prices[i]);

          }
          return maxProfit;
      }
  }
变体，绝对值表达式的最大值（leetcode [1131] Maximum of Absolute Value Expression）
  思路：
    参考1：https://www.cnblogs.com/fish1996/p/11261100.html
    参考2：https://coordinate.wang/index.php/archives/2540/
  代码：
  class Solution {
      public int maxAbsValExpr(int[] arr1, int[] arr2) {
          if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
              return 0;
          }
          int[][] count = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
          // 本质是股票只买卖一次的变体
          // 需要将绝对值符号分类拆开，按照i和j分类放到一起(i > j)
          int ans = Integer.MIN_VALUE;
          for (int cnt = 0; cnt < count.length; ++cnt) {
              int minPrice = Integer.MAX_VALUE;
              for (int i = 0; i < arr1.length; ++i) {
                  int cur = arr1[i] * count[cnt][0] + arr2[i] * count[cnt][1] + i;
                  int profit = i == 0 ? 0 : cur - minPrice;
                  ans = Math.max(ans, profit);
                  minPrice = Math.min(minPrice, cur);
              }
          }
          return ans;
      }
  }

  
2.2.2.股票可以买卖无数次（leetcode [122] Best Time to Buy and Sell Stock II）
  思路：在价格曲线图中，曲线斜率大于0表示有利润，曲线斜率小于0表示亏本，在可以买卖无数次的情况下，只要斜率大于0就交易，即只要价格大于前一天就买，就算后一天
  价格大于今天利润更大也可以今天买了之后再买入，利润是不变的
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int profits = 0;
          for (int i = 1; i < prices.length; ++i) {
              int temp = prices[i] - prices[i-1];
              if (temp > 0) {
                  profits += temp;
              }
          }
          return profits;
      }
  }
  
2.2.3.股票可以买卖两次（leetcode [123] Best Time to Buy and Sell Stock III）
  思路：结合当前卖出能赚的利润(最大利润)和当前买入能赚的利润(最大利润)
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int len = prices.length;
          // 当前卖出能赚的利润(最大利润)
          int[] dp1 = new int[len];
          // 当前买入能赚的利润(最大利润)
          int[] dp2 = new int[len];
          int minPrice = prices[0];
          for (int i = 1; i < len; ++i) {            
              dp1[i] = Math.max(prices[i] - minPrice, dp1[i-1]);
              minPrice = Math.min(minPrice, prices[i]);         
          }
          int maxPrice = prices[len-1];
          for (int i = len-2; i >= 0; --i) {           
              dp2[i] = Math.max(maxPrice - prices[i], dp2[i+1]);
              maxPrice = Math.max(maxPrice, prices[i]);          
          }
          int ans = 0;
          for (int i = 0; i < len; ++i) {
              ans = Math.max(ans, dp1[i] + dp2[i]);
          }
          return ans;
      }
  }
2.2.4.股票可以买卖k次（leetcode [188] Best Time to Buy and Sell Stock IV）
  思路：当k >= len/2时，问题就退化成了可以交易任意次了，所以只要将任意两天股票差大于０的加起来即可．当k < len/2时，可以记录k次交易每次买之后和卖以后
最大的利润：１．第ｉ次买操作买下当前股票之后剩下的最大利润为第(i-1)次卖掉股票之后的利润－当前的股票价格．状态转移方程为：
                buy[i] = max(sell[i-1]- curPrice, buy[i]);
          ２．第ｉ次卖操作卖掉当前股票之后剩下的最大利润为第ｉ次买操作之后剩下的利润＋当前股票价格．状态转移方程为：
                sell[i] = max(buy[i]+curPrice, sell[i]);
  
  代码：
  class Solution {
      public int maxProfit(int k, int[] prices) {
          int len = prices.length;
          if (k >= len/2) {
              int profit = 0;
              for (int i = 1; i < len; ++i) {
                  if (prices[i] > prices[i-1]) {
                      profit += prices[i] - prices[i-1];
                  }
              }
              return profit;
          }        
          int[] buy = new int[k+1];
          int[] sell = new int[k+1];
          // buy数组初始化为整数最小值是为了确保每件商品购入时最大利润不为0
          Arrays.fill(buy, Integer.MIN_VALUE);
          // 从每件商品开始
          for (int price : prices) {
              for (int i = 1; i <= k; ++i) {
                  buy[i] = Math.max(buy[i], sell[i-1] - price);
                  sell[i] = Math.max(sell[i], buy[i] + price);
              }
          }
          return sell[k];
      }
  }
2.2.5.股票买卖(无限次)含冷冻期（leetcode [309] Best Time to Buy and Sell Stock with Cooldown）
  思路：
  考虑第i天不持有dp[i][0]和持有dp[i][1]的转移方程：
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i])
    dp[i][1]=max(dp[i-1][1],dp[i-2][0]-p[i])
  压缩
    可以对i这个属性进行压缩，但是计算i需要i-1和i-2的信息，所以至少需要三行记录（类似斐波那契求解）
    cur[1]=max(bf1[1],bf2[0]-p[i])
    cur[0]=max(bf1[0],bf1[1]+p[i])
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int[] cur = new int[2];
          int[] bf1 = new int[2];
          int[] bf2 = new int[2];
          bf1[0] = 0;
          bf1[1] = -prices[0];
          bf2[0] = 0;
          for (int i = 1; i < prices.length; ++i) {
              cur[0] = Math.max(bf1[1] + prices[i], bf1[0]);
              cur[1] = Math.max(bf2[0] - prices[i], bf1[1]);
              bf2[0] = bf1[0];
              bf2[1] = bf1[1];
              bf1[0] = cur[0];
              bf1[1] = cur[1];
          }
          return cur[0];
      }
  }
2.2.6.股票买卖(无限次)含手续费（leetcode [714] Best Time to Buy and Sell Stock with Transaction Fee）
  思路：
  考虑第i天不持有dp[i][0]和持有dp[i][1]的转移方程：
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i])
    dp[i][1]=max(dp[i-1][1],dp[i-1][0]-p[i]-fee)
  压缩
    可以对i这个属性进行压缩，但是计算i需要i-1和i-2的信息，所以至少需要三行记录（类似斐波那契求解）
    cur[0] = max(bf1[0], bf1[1] + prices[i])
    cur[1] = max(bf1[1], bf1[0] - prices[i] - fee)
  代码：
  class Solution {
      public int maxProfit(int[] prices, int fee) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int[] bf1 = new int[2];
          int[] cur = new int[2];
          bf1[0] = 0;
          bf1[1] = -prices[0] - fee;
          for (int i = 1; i < prices.length; ++i) {
              cur[0] = Math.max(bf1[0], bf1[1] + prices[i]);
              cur[1] = Math.max(bf1[1], bf1[0] - prices[i] - fee);
              bf1[0] = cur[0];
              bf1[1] = cur[1];
          }
          return cur[0];
      }
  }
  
2.3.斐波那契类型
2.3.1.爬楼梯的最小代价（leetcode [746] Min Cost Climbing Stairs）
  代码：
  class Solution {
      public int minCostClimbingStairs(int[] cost) {
          if (cost.length == 2) {
              return Math.min(cost[0], cost[1]);
          }
          // dp[i] = min{dp[i-1], dp[i-2]} + cost[i]
          int a = cost[0];
          int b = cost[1];
          int c = 0;
          for (int i = 2; i < cost.length; ++i) {
              c = Math.min(a, b) + cost[i];
              a = b;
              b = c;

          }
          return Math.min(a, b);
      }
  }
2.3.2.爬楼梯的方案总数（leetcode [70] Climbing Stairs）
  代码：
  class Solution {
      public int climbStairs(int n) {
          int a = 1;
          int b = 2;
          if (n < 1) {
              return 0;
          }
          if (n == 1) {
              return a;
          }
          if (n == 2) {
              return b;
          }
          int c = 0;
          // dp[i] = dp[i-1] + dp[i-2]
          for (int i = 3; i <= n; ++i) {
              c = a + b;
              a = b;
              b = c;
          }
          return c;
      }
  }
  
2.4.序列/数组中的dp
2.4.1.最大连续子序和（leetcode [53] Maximum Subarray）
  代码：
  class Solution {
      public int maxSubArray(int[] nums) {
          if (nums == null || nums.length == 0) {
              return 0;
          }
          int a = nums[0];
          int b = 0;
          int ans = a;
          // dp[i]表示以结尾的最大连续子序和
          // dp[i] = max{dp[i-1]+nums[i], nums[i]}
          for (int i = 1; i < nums.length; ++i) {
              b = Math.max(a + nums[i], nums[i]);
              ans = Math.max(b, ans);
              a = b;
          }
          return ans;
      }
  }
2.4.2.矩阵的前序和（leetcode 1314. Matrix Block Sum）
  代码：
  class Solution {
      public int[][] matrixBlockSum(int[][] mat, int K) {
          int m = mat.length;
          int n = mat[0].length;
          int[][] sums = new int[m+1][n+1];
          int[][] ans = new int[m][n];
          for (int i = 1; i <= m; ++i) {
              for (int j = 1; j <= n; ++j) {
                  sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + mat[i-1][j-1];
              }
          }
          int k = K;
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  int x1 = Math.min(i+k+1, m);
                  int y1 = Math.min(j+k+1, n);
                  int x0 = Math.max(i-k, 0);
                  int y0 = Math.max(j-k, 0);
                  ans[i][j] = sums[x1][y1] + sums[x0][y0] - sums[x1][y0] - sums[x0][y1];
              }
          }
          return ans;
      }
  }
矩阵类相关之正方形个数计算问题（leetcode 1277. Count Square Submatrices with All Ones）
  代码：
  class Solution {
      public int countSquares(int[][] matrix) {
          int m = matrix.length;
          int n = matrix[0].length;
          int[][] sums = new int[m+1][n+1];
          int ans = 0;
          int th = Math.min(m, n);
          for (int i = 1; i <= m; ++i) {
              for (int j = 1; j <= n; ++j) {
                  sums[i][j] = matrix[i-1][j-1] + sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1];
                  for (int t = 1; t <= th; ++t) {
                      int x0 = Math.max(i-t, 0);
                      int y0 = Math.max(j-t, 0);
                      if (sums[i][j] - sums[x0][j] - sums[i][y0] + sums[x0][y0] != t*t) {
                          break;
                      }
                      ++ans;
                  }
              }
          }
          return ans;
      }
  }
2.4.3.下降路径的最小和（leetcode [931] Minimum Falling Path Sum）
  代码：
  class Solution {
    public int minFallingPathSum(int[][] A) {
        int n = A.length;
        int[][] dp = new int[2][n];
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; ++i) {
            dp[0][i] = A[n-1][i];
            ans = Math.min(ans, dp[0][i]);
        }
        if (n == 1) {
            return ans;
        }
        ans = Integer.MAX_VALUE;
        for (int cnt = 1; cnt < n; ++cnt) {
            int index = cnt & 1;
            for (int i = 0; i < n; ++i) {
                int minVal = dp[1-index][i];
                if (i-1 >= 0) {
                    minVal = Math.min(minVal, dp[1-index][i-1]);
                }
                if (i+1 < n) {
                    minVal = Math.min(minVal, dp[1-index][i+1]);
                }
                dp[index][i] = A[n-1-cnt][i] + minVal;
                if (cnt == n-1) {
                    ans = Math.min(ans, dp[index][i]);
                }
            }
            
        }
        return ans;
    }
}
2.4.4.最长公共子序列及其优化（leetcode [1143] Longest Common Subsequence）
  代码：
  class Solution {
      public int longestCommonSubsequence(String text1, String text2) {
          int m = text1.length();
          int n = text2.length();
          int[][] dp = new int[2][n+1];
          // dp[i][j] = if str1(i) == str2(j) dp[i-1][j-1] ; else Math.max( dp[i-1][j],  dp[i][j-1])
          for (int i = 1; i <= m; ++i) {
              int index = i & 1;
              for (int j = 1; j <= n; ++j) {
                  dp[index][j] = text1.charAt(i-1)==text2.charAt(j-1) ? dp[1-index][j-1] + 1: Math.max(dp[1-index][j], dp[index][j-1]);
              }
          }
          return dp[1&m][n];
      }
  }
变体1.两字符串成为相同字符串去除字符ASCII最小和（leetcode [712] Minimum ASCII Delete Sum for Two Strings）
  代码：
  class Solution {
      public int minimumDeleteSum(String s1, String s2) {
          int m = s1.length();
          int n = s2.length();
          int[][] dp = new int[2][n+1];
          // 总值一定，减去的最小和即为公共子串的最大和
          // dp[i][j]表示两个字符串i，j位置时的最大公串和
          for (int i = 1; i <= m; ++i) {
              int index = i & 1;
              for (int j = 1; j <= n; ++j) {
                  dp[index][j] = Math.max(dp[index][j-1], dp[1-index][j]);
                  if (s1.charAt(i-1) == s2.charAt(j-1)) {
                      dp[index][j] = Math.max(dp[index][j], dp[1-index][j-1] + (s1.charAt(i-1) - 'a') + 97);
                  }
              }
          }
          int sum1 = 0;
          int sum2 = 0;
          for (int i = 0; i < m; ++i) {
              sum1 += s1.charAt(i) - 'a' + 97;
          }
          for (int i = 0; i < n; ++i) {
              sum1 += s2.charAt(i) - 'a' + 97;
          }
          return sum1 + sum2 - 2 * dp[m&1][n];

      }
  }
变体2，一个字符串的最长回文子序列（leetcode [516] Longest Palindromic Subsequence）
  思路：
  一个字符串的回文子序列就是从正着数和倒着数的公共子序列，求一个字符串的最长回文子序列就是求一个字符串和其逆序字符串的最长公共子序列
  代码：
  class Solution {
      public int longestPalindromeSubseq(String s) {
          if (s == null || s.length() < 1) {
              return 0;
          }
          int len = s.length();
          String str1 = new StringBuilder(s).reverse().toString();
          int[][] dp = new int[2][len+1];
          for (int i = 1; i <= len; ++i) {
              int index = i & 1;
              for (int j = 1; j <= len; ++j) {
                  dp[index][j] = s.charAt(i-1)==str1.charAt(j-1) ? dp[1-index][j-1] + 1: Math.max(dp[index][j-1], dp[1-index][j]);
              }
          }
          return dp[len&1][len];
      }
  }
变体3，最长公共子串（leetcode [718] Maximum Length of Repeated Subarray）
  代码：
  class Solution {
      public int findLength(int[] A, int[] B) {
          int m = A.length;
          int n = B.length;
          int[][] dp = new int[2][n+1];
          int ans = 0;
          // dp[i][j] = dp[i-1][j-1] if A[i]==B[j]; 0 ,else;
          for (int i = 1; i <= m; ++i) {
              int index = i & 1;
              for (int j = 1; j <= n; ++j) {
                  dp[index][j] = A[i-1]==B[j-1] ? dp[1-index][j-1] + 1: 0;
                  ans = Math.max(ans, dp[index][j]);
              }

          }
          return ans;
      }
  }

2.4.5.书架填充的最小高度（leetcode [1105] Filling Bookcase Shelves）
  代码：
  class Solution {
      public int minHeightShelves(int[][] books, int shelf_width) {
          int len = books.length;
          int[] dp = new int[len+1];
          Arrays.fill(dp, 1000*1000);
          dp[0] = 0;
          // dp[i] 表示前i本书的最小高度，比较时，从第i本书单独一个书架高度至第i本书最多与前面几本书可以同一个书架，找最小
          for (int i = 1; i <= len; ++i) {
              int j = i - 1;
              int temp_h = 0;
              int temp_w = 0;
              while (j >= 0) {
                  temp_w += books[j][0];
                  if (temp_w > shelf_width) {
                      break;
                  }
                  temp_h = Math.max(temp_h, books[j][1]);
                  dp[i] = Math.min(dp[i], dp[j] + temp_h);
                  --j;
              }
          }
          return dp[len];
      }
  }
变体，删除或获得点数的最大值（leetcode [740] Delete and Earn）
  代码：
  class Solution {
      public int deleteAndEarn(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int n = nums.length;
          Arrays.sort(nums);
          int[] dp = new int[n+1];
          dp[0] = 0;
          int ans = 0;
          dp[1] = nums[0];
          ans = dp[1];
          // dp[i] 是以第i个元素结尾的最大和
          // dp[i] = max{nums[i-1] + dp[j]}, j < i && nums[i-1]-nums[j-1] != 1
          for (int i = 2; i <= n; ++i) {
              for (int j = i-1; j >= 1; --j) {
                  while ((j >= 1) && (nums[i-1] - nums[j-1] == 1)) {
                      --j;
                  }
                  dp[i] = Math.max(dp[i], nums[i-1] + dp[j]);
              }            
              ans = Math.max(ans, dp[i]);
          }
          return ans;
      }
  }
2.4.6.递增串个数（leetcode [413] Arithmetic Slices）
  代码：
  class Solution {
      public int numberOfArithmeticSlices(int[] A) {
          if (A == null || A.length < 3) {
              return 0;
          }
          int len = A.length;
          int[] dp = new int[len];
          dp[0] = 0;
          dp[1] = 0;
          int ans = 0;
          // dp[i] 表示以 i 结尾的串长度
          for (int i = 2; i < len; ++i) {
              dp[i] = A[i]-A[i-1]==A[i-1]-A[i-2] ? dp[i-1]+1: 0;
              ans += dp[i];
          }
          return ans;
      }
  }
2.4.7.数列中的最长等差数列长度（leetcode [1027] Longest Arithmetic Sequence）
  代码：
  class Solution {
      public int longestArithSeqLength(int[] A) {
          if (A == null || A.length < 3) {
              return 0;
          }
          int[][] dp = new int[A.length][20005];
          int ans = 0;
          // dp[i][len] 表示位置为i的字符和i之前字符值为len的等差数列长度
          for (int i = 1; i < A.length; ++i) {
              for (int j = 0; j < i; ++j) {
                  int dis = A[i] - A[j] + 10000;
                  // 第一次出现这个distance
                  /*
                  if (dp[i][dis] == 0) {
                      dp[i][dis] = dp[j][dis] == 0 ? 2: dp[j][dis]+1;
                  } else {
                      dp[i][dis] = Math.max(dp[i][dis], dp[j][dis] == 0 ? 2: dp[j][dis]+1);
                  }
                  */
                  dp[i][dis] = Math.max(dp[i][dis], dp[j][dis] == 0 ? 2: dp[j][dis]+1);
                  ans = Math.max(ans, dp[i][dis]);
              }
          }
          return ans;
      }
  }
2.4.8.最长字符串链长度（leetcode [1048] Longest String Chain）
  代码：
  class Solution {
      public int longestStrChain(String[] words) {
          int[] dp = new int[words.length];
          Arrays.fill(dp, 1);
          Arrays.sort(
              words,
              (a, b) -> a.length() - b.length()
          );
          int ans = 1;
          // dp[i]表示以第i位置结尾的字符串链长度
          for (int i = 1; i < words.length; ++i) {
              for (int j = i-1; j >= 0; --j) {
                  if (words[j].length() ==  words[i].length()) {
                      continue;
                  } else if (words[j].length() + 1 <  words[i].length()) {
                      break;
                  }
                  if (compare(words[j], words[i])) {
                      dp[i] = Math.max(dp[i], dp[j] + 1);
                  }
              }
              ans = Math.max(ans, dp[i]);
          }
          return ans;
      }

      public boolean compare (String str1, String str2) {
          int j = 0;
          for (int i = 0; i < str2.length() && j < str1.length(); ++i) {
              if (str1.charAt(j) == str2.charAt(i)) {
                  ++j;
              }
          }
          return j == str1.length();
      }

  }
2.4.9.矩阵左上到右下的路径数（leetcode [62] Unique Paths）
  代码：
  class Solution {
      public int uniquePaths(int m, int n) {
          int[][] dp = new int[2][n+1];
          dp[0][1] = 1;
          // dp[i][j] = dp[i-1][j] + dp[i][j-1]
          for (int i = 1; i <= m; ++i) {
              int index = i & 1;
              for (int j = 1; j <= n; ++j) {
                  dp[index][j] = dp[index][j-1] + dp[1-index][j];
              }
          }
          return dp[m&1][n];
      }
  }
变体，矩阵左上到右下的最短路径和（leetcode [64] Minimum Path Sum）
  代码：
  class Solution {
      public int minPathSum(int[][] grid) {
          int m = grid.length;
          int n = grid[0].length;
          int[][] dp = new int[2][n+1];
          // dp[i][j] = grid[i][j] + min{dp[i-1][j], dp[i][j-1]}
          for (int i = 1; i <= m; ++i) {
              int index = i & 1;
              for (int j = 1; j <= n; ++j) {
                  if (i == 1) {
                      dp[index][j] = grid[i-1][j-1] + dp[index][j-1];
                  } else if (j == 1) {
                      dp[index][j] = grid[i-1][j-1] + dp[1-index][j];
                  } else {
                      dp[index][j] = grid[i-1][j-1] + Math.min(dp[index][j-1], dp[1-index][j]);
                  }

              }
          }
          return dp[m&1][n];
      }
  }
2.4.10.最长数对的链长（leetcode [646] Maximum Length of Pair Chain）
  代码：
  class Solution {

      public class Pair {
          int x;
          int y;
          public Pair (int a, int b) {
              x = a;
              y = b;
          }
      }

      public int findLongestChain(int[][] pairs) {
          int n = pairs.length;
          Pair[] p = new Pair[n];
          for (int i = 0; i < n; ++i) {
              p[i] = new Pair(pairs[i][0], pairs[i][1]);
          }
          Arrays.sort(
              p,
              (a, b) -> {
                  if (a.y == b.y) {
                      return a.x - b.x;
                  } else {
                      return a.y - b.y;
                  }
              }
          );
          int[] dp = new int[n+1];
          dp[1] = 1;
          int ans = 1;
          // dp[i] = dp[j] + 1, j < i && p[j].y < p[i].x
          for (int i = 2; i <= n; ++i) {
              dp[i] = 1;
              for (int j = i - 1; j >= 1; --j) {
                  if (p[j-1].y < p[i-1].x) {
                      dp[i] = Math.max(dp[j] + 1, dp[i]);
                  }
              }
              ans = Math.max(dp[i], ans);
          }
          return ans;
      }
  }
变体，视频拼接（leetcode [1024] Video Stitching）
  代码：
  class Solution {

        public class Line {
            int left;
            int right;
            public Line (int a, int b) {
                left = a;
                right = b;
            }
        }

        public int videoStitching(int[][] clips, int T) {
            int n = clips.length;
            int maxVal = 100_000_0000;
            Line[] lines = new Line[n];
            for (int i = 0; i < n; ++i) {
                lines[i] = new Line(clips[i][0], clips[i][1]);
            }
            Arrays.sort(
                lines,
                (a, b) -> {
                    if (a.left == b.left) {
                        return a.right - b.right;
                    } else {
                        return a.left - b.left;
                    }
                }
            );
            int[] dp = new int[T+1];
            Arrays.fill(dp, maxVal);
            dp[0] = 0;
            // dp[i] 表示到达i的最少段数
            for (int i = 1; i <= T; ++i) {
                for (Line line : lines) {
                    if (i < line.left) {
                        break;
                    }
                    if (i > line.left && i <= line.right) {
                        dp[i] = Math.min(dp[i], dp[line.left] + 1);
                    }
                }
            }
            return dp[T] == maxVal ? -1 : dp[T];
        }
    }

  2.4.11.数组最多有k个分组的最大均值和（leetcode [813] Largest Sum of Averages）
    代码：
    class Solution {
        public double largestSumOfAverages(int[] A, int K) {
            int n = A.length;
            double[] sums = new double[n+1];
            for (int i = 1; i <= n; ++i) {
                sums[i] = A[i-1] + sums[i-1];
            }
            double[][] dp = new double[2][n+1];
            for (int i = 1; i <= n; ++i) {
                dp[1][i] = sums[i]/i;
            }
            // dp[i,k]表示前i个元素有k个分组的最大均值和，dp[i,k]和dp[k,i]一样
            // dp[i,k] = max{dp[j, k-1] + (nums[j+1]+...nums[i])/(i-j)}
            for (int k = 2; k <= K; ++k) {
                int index = k & 1;
                for (int i = 1; i <= n; ++i) {
                    double temp = dp[1-index][i];
                    for (int j = 1; j < i; ++j) {
                        temp = Math.max(temp, dp[1-index][j] + (sums[i]-sums[j])/(i-j));
                    }
                    dp[index][i] = temp;
                }
            }
            return dp[K&1][n];
        }
    }
2.4.12.最多经历k个中转到达目的地的最小票价（leetcode 787. Cheapest Flights Within K Stops）
  代码：
  class Solution {
      public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
          // dp[i][dst] = min{dp[i-1][src] + value[src][dst]}
          // dp[i][dst]表示通过i个中间节点到目的节点dst的最小距离
          int[][] dp = new int[2][n];
          // int INF = Integer.MAX_VALUE/2;
          int INF = 10_000_000;
          for (int  i = 0; i < dp.length; ++i) {
              for (int j = 0; j < dp[i].length; ++j) {
                  dp[i][j] = INF;
              }
          }
          for (int[] flight : flights) {
              if (src == flight[0]) {
                  dp[0][flight[1]] = flight[2];
              }
          }   
          // Arrays.fill(dp, 10_000_005);
          dp[0][src] = 0;
          for (int i = 1; i <= K; ++i) {
              for (int[] flight : flights) {
                  int s = flight[0];
                  int d = flight[1];
                  int v = flight[2];
                  dp[i&1][d] = Math.min(dp[i&1][d], dp[1-i&1][s] + v);
              }
          }
          return dp[K&1][dst] >= INF ? -1 : dp[K&1][dst];
      }
  }
  
2.5.小偷偷盗问题
2.5.1.普通小偷偷盗问题（leetcode [198] House Robber）
  代码：
  class Solution {
      public int rob(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          /*
          int bf0 = 0;
          int bf1 = nums[0];
          int cur0 = bf0;
          int cur1 = bf1;
          // dp[i][0] = max{dp[i-1][0], dp[i-1][1]}
          // dp[i][1] = dp[i-1][0] + nums[i]
          for (int i = 1; i < nums.length; ++i) {
              cur0 = Math.max(bf0, bf1);
              cur1 = bf0 + nums[i];
              bf0 = cur0;
              bf1 = cur1;
          }
          return Math.max(cur0, cur1);
          */
          if (nums.length == 1) {
              return nums[0];
          }
          int a = nums[0];
          int b = Math.max(nums[0], nums[1]);
          int c = b;
          // dp[i] = max{nums[i] + dp[i-2], dp[i-1]}
          // dp[i]表示偷到第i家能获得的最大利润
          for (int i = 2; i < nums.length; ++i) {
              c = Math.max(nums[i] + a, b);
              a = b;
              b = c;
          }
          return c;
      }
  }
2.5.2.小偷偷盗成环问题（leetcode [213] House Robber II）
  代码：
  class Solution {
      public int rob(int[] nums) {
          if (nums == null || nums.length == 0) {
              return 0;
          }
          if (nums.length == 1) {
              return nums[0];
          }
          if (nums.length == 2) {
              return Math.max(nums[0], nums[1]);
          }
          if (nums.length == 3) {
              return Math.max(Math.max(nums[0], nums[2]), nums[1]);
          }
          // 从第1个房子偷到第n-1个房子的最大值
          int a1 = nums[0];
          int b1 = Math.max(nums[1], nums[0]);
          int c1 = b1;
          for (int i = 2; i < nums.length - 1; ++i) {
              c1 = Math.max(nums[i] + a1, b1);
              a1 = b1;
              b1 = c1;
          }
          // 从第2个房子偷到第n个房子的最大值
          int a2 = nums[1];
          int b2 = Math.max(nums[2], nums[1]);
          int c2 = b2;
          for (int i = 3; i < nums.length; ++i) {
              c2 = Math.max(nums[i] + a2, b2);
              a2 = b2;
              b2 = c2;
          }
          return Math.max(c1, c2);
      }
  }
2.5.3.偷盗成树问题（leetcode [337] House Robber III）
  代码：
  class Solution {

      public class Point{
          int c0;
          int c1;
          public Point(int x, int y){
              c0 = x;
              c1 = y;
          }
      }

      public Point dfs (TreeNode node) {
          if (node == null ) {
              return new Point(0, 0);
          }
          // 0表示到不偷该节点的以该节点为根的最大偷盗和
          // 1表示到偷该节点的以该节点为根的最大偷盗和
          // root[0] = max{left[0], left[1]} + max{right[0], right[1]}
          // root[1] = root.val + left[0] + right[0]
          Point left = dfs(node.left);
          Point right = dfs(node.right);
          int c0 = Math.max(left.c0, left.c1) + Math.max(right.c0, right.c1);
          int c1 = node.val + left.c0 + right.c0;
          return new Point(c0, c1);
      }

      public int rob(TreeNode root) {
          Point ans  = dfs(root);
          return Math.max(ans.c0, ans.c1);
      }
  }
  
2.6.博弈问题
2.6.1.石子堆先后手选择问题（leetcode [877] Stone Game）
  代码：
  class Solution {

      public class Pair {
          int fir;
          int sec;
          public Pair (int a, int b) {
              fir = a;
              sec = b;
          }
      }

      public boolean stoneGame(int[] piles) {
          int n = piles.length;
          Pair[] dp = new Pair[n];
          for (int i = 0; i < n; ++i) {
              dp[i] = new Pair(piles[i], 0);
          }
          for (int l = 1; l < n; ++l) {
              int j = l;
              for (int i = 0; i < n - l; ++i) {
                  int left = piles[i] + dp[i+1].sec;
                  int right = piles[j] + dp[i].sec;
                  int temp = dp[i].fir;
                  dp[i].fir = Math.max(left, right);
                  dp[i].sec = left > right ? dp[i+1].fir: temp;
                  ++j;
              }

          }
          return dp[0].fir > dp[0].sec;
          /*
          Pair[][] dp = new Pair[n][n];
          for (int i = 0; i < n; ++i) {
              for (int j = 0; j < n; ++j) {
                  dp[i][j] = new Pair(0, 0);
                  if (i == j) {
                      dp[i][j].fir = piles[i];
                  }
              }
          }
          for (int l = 1; l < n; ++l) {
              int j = l;
              for (int i = 0; i < n - l; ++i) {
                  int left = piles[i] + dp[i+1][j].sec;
                  int right = piles[j] + dp[i][j-1].sec;
                  dp[i][j].fir = Math.max(left, right);
                  dp[i][j].sec = left > right ? dp[i+1][j].fir: dp[i][j-1].fir;
                  ++j;
              }
          }
          return dp[0][n-1].fir > dp[0][n-1].sec;
          */
      }
  }
变体；赢家预测问题，解法一致（leetcode [486] Predict the Winner）
  代码：
  class Solution {

      public class Pair{
          int fir;
          int sec;
          public Pair(int a, int b) {
              fir = a;
              sec = b;
          }
      }

      public boolean PredictTheWinner(int[] nums) {
          int n = nums.length;
          Pair[][] dp = new Pair[n][n];
          // dp[i][j]表示从第i到j个商品最大，fir表示先手，sec表示后手
          for (int i = 0; i < n; ++i) {
              dp[i][i] = new Pair(nums[i], 0);
          }
          // dp[i][j].fir = max{nums[i] + dp[i+1][j].sec, nums[j] + dp[i][j-1].sec}
          // dp[i][j].sec = dp[i+1][j].fir, 先手选左堆； dp[i][j-1].fir, 先手选右堆；
          for (int cnt = 1; cnt < n; ++cnt) {
              int j = cnt;
              for (int i = 0; i < n - cnt; ++i) {
                  int left = nums[i] + dp[i+1][j].sec;
                  int right = nums[j] + dp[i][j-1].sec;
                  int fir = Math.max(left, right);
                  int sec = left > right ? dp[i+1][j].fir : dp[i][j-1].fir;
                  dp[i][j] = new Pair(fir, sec);
                  ++j;
              }
          }
          return dp[0][n-1].fir >= dp[0][n-1].sec;
      }
  }
2.6.2.石子堆选择堆数加限制（leetcode [1140] Stone Game II）
  代码：
  class Solution {
      public int stoneGameII(int[] piles) {
          int n = piles.length;
          int[][] dp = new int[n+1][n+1];
          int[] sums = new int[n+1];
          for (int i = 1; i <= n; ++i) {
              sums[i] = sums[i-1] + piles[i-1];
          }
          // dp[i][j]表示剩余i堆且M为j时的最大数量
          // dp[i][j] = max{(sums[n]-sums[n-i])-dp[i-k][max(k,j)]} k>=1 && k <= 2*j
          for (int i = 1; i <= n; ++i) {
              for (int j = 1; j <= n; ++j) {
                  for (int k = 1; k <= 2*j && k <= i; ++k) {
                      dp[i][j] = Math.max(dp[i][j], sums[n] - sums[n-i] - dp[i-k][Math.min(Math.max(j,k), n)]);
                  }

              }
          }
          return dp[n][1];
      }
  }
2.6.3.多米诺骨牌问题（leetcode [838] Push Dominoes）
  代码：
  class Solution {
      public String pushDominoes(String dominoes) {
          if (dominoes == null || dominoes.length() < 1) {
              return "";
          }
          int n = dominoes.length();
          int[] indexes = new int[n+2];
          char[] symbols = new char[n+2];
          char[] ans = dominoes.toCharArray();
          int len = 0;
          // 加一个头，不影响全局
          indexes[len] = -1;
          symbols[len++] = 'L'; 
          for (int i = 0; i < n; ++i) {
              if (ans[i] != '.') {
                  indexes[len] = i;
                  symbols[len++] = ans[i];
              }
          }
          // 加一个尾，不影响全局
          indexes[len] = n;
          symbols[len] = 'R';
          for (int i = 0; i < len; ++i) {
              int x = indexes[i];
              int y = indexes[i+1];
              char a = symbols[i];
              char b = symbols[i+1];
              if (a == b) {
                  // L...L or R....R
                  for (int k = x + 1; k < y; ++k) {
                      ans[k] = a;
                  }
              } else if (a > b) {
                  // R.....L
                  for (int k = x + 1; k < y; ++k) {
                      ans[k] = k-x==y-k ? '.' : k-x < y-k ? 'R': 'L';
                  }
              }
          }
          return new String(ans);
      }
  }

2.7.字符串
2.7.1.判断字符串中回文子串的个数（leetcode [647] Palindromic Substrings）
  代码：
  class Solution {
      public int countSubstrings(String s) {
          int n = s.length();
          boolean[][] dp = new boolean[n][n];
          int ans = 0;
          // dp[start][end] = (s.charAt(start)==s.charAt(end)) && dp[start+1][end-1]
          for (int end = 0; end < n; ++end) {
              for (int start = end; start >= 0; --start) {
                  if (start == end) {
                      dp[start][end] = true;
                      ++ans;
                  } else if (end - start == 1) {
                      if (s.charAt(start) == s.charAt(end)) {
                          dp[start][end] = true;
                          ++ans;
                      }
                  } else if (end - start >= 2) {
                      if (s.charAt(start) == s.charAt(end) && dp[start+1][end-1]) {
                          dp[start][end] = true;
                          ++ans;
                      }
                  }
              }
          }
          return ans;
      }
  }
  
2.8.背包类型问题
2.8.1.最低票价（leetcode [983] Minimum Cost For Tickets）
  代码：(记忆搜索优化)
  class Solution {
      int[] days;
      int[] costs;
      Integer[] memory;
      int[] durations = {1, 7, 30};

      public int mincostTickets(int[] days, int[] costs) {
          this.days = days;
          this.costs = costs;
          memory = new Integer[days.length];
          return dp(0);
      }

      // dp(i)表示从day[i]到最后的最小花费
      public int dp (int i) {
          if (i >= days.length) {
              return 0;
          }
          if (memory[i] != null) {
              return memory[i];
          }
          int ans = Integer.MAX_VALUE;
          for (int k = 0; k < 3; ++k) {
              int j = i;
              while (j < days.length && days[j] < days[i] + durations[k]) {
                  ++j;
              }
              ans = Math.min(ans, dp(j) + costs[k]);
          }
          memory[i] = ans;
          return ans;
      }

  }




分割数组得到最大和（leetcode [1043] Partition Array for Maximum Sum）
  代码：
  class Solution {
      public int maxSumAfterPartitioning(int[] A, int K) {
          int len = A.length;
          int[] dp = new int[len + 1];
          for (int i = 0; i <= len; ++i) {      
              int max = Integer.MIN_VALUE;
              for (int j = i - 1; j >= 0 && i-j <= K; --j) {
                  max = Math.max(max, A[j]);
                  dp[i] = Math.max(dp[i], dp[j] + max * (i-j));
              }
          }
          return dp[len];
      }
  }


素数表自定义的丑数（leetcode [313] Super Ugly Number）
  参考：https://www.cnblogs.com/lightwindy/p/9758211.html
  代码：
  class Solution {
      public int nthSuperUglyNumber(int n, int[] primes) {
          int[] ugly = new int[n+1];
          int[] postions = new int[primes.length];
          ugly[0] = 1;
          for (int i = 1; i <= n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ugly[postions[j]] * primes[j]) {
                      minVal = ugly[postions[j]] * primes[j];
                      index = j;
                  } else if (minVal == ugly[postions[j]] * primes[j]) {
                      ++postions[j];
                  }
              }
              ugly[i] = minVal;
              ++postions[index];
          }
          return ugly[n-1];
      }
  }
丑数基本原型（leetcode [264] Ugly Number II）
  代码：
  class Solution {
      public int nthUglyNumber(int n) {
          int[] ans = new int[n];
          ans[0] = 1;
          int[] primes = {2, 3, 5};
          int[] pos = new int[primes.length];
          for (int i = 1; i < n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ans[pos[j]] * primes[j]) {
                      minVal = ans[pos[j]] * primes[j];
                      index = j;
                  } else if (minVal == ans[pos[j]] * primes[j]) {
                      ++pos[j];
                  }                
              }
              ++pos[index];
              ans[i] = minVal;
          }
          return ans[n-1];
      }
  }


