1.基础知识
1.1.基础：https://juejin.im/post/5d1418a5e51d45108c59a57c#heading-2
1.2.背包九讲：https://www.kancloud.cn/kancloud/pack/70125
1.3.背包九讲java实现：https://www.zhihu.com/people/liu-xun-39-54/posts
1.4.最长公共子序列和最长公共子串(最长共同子序列)：https://www.cnblogs.com/en-heng/p/3963803.html

2.1.数的除法
2.1.1.除数博弈（leetcode [1025] Divisor Game）
  代码：
  class Solution {
      public boolean divisorGame(int N) {
          // 最优的数不是最大的约数，而是能找到的让自己立于不败之地的最合适的数
          if (N <= 1) {
              return false;
          }
          boolean[] dp = new boolean[N+1];
          dp[1] = false;
          dp[2] = true;
          for (int i = 3; i <= N; ++i) {
              for (int j = 1; j < i; ++j) {
                  if (i%j==0 && !dp[i-j]) {
                      dp[i] = true;
                      break;
                  }
              }
          }
          return dp[N];
      }

  }
  
2.2.股票买卖
2.2.1.股票只能买卖一次（leetcode [121] Best Time to Buy and Sell Stock）
  思路：在价格曲线图中，纵轴差值的绝对值表示盈利或者亏本的金额，买卖一次，最大利润即为找盈利情况下的最大差值
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int maxProfit = 0;
          int minPrice = prices[0];
          for (int i = 1; i < prices.length; ++i) {
              int tempProfit = prices[i] - minPrice > 0 ? prices[i] - minPrice : 0;
              maxProfit = Math.max(maxProfit, tempProfit);
              minPrice = Math.min(minPrice, prices[i]);

          }
          return maxProfit;
      }
  }
  
2.2.2.股票可以买卖无数次（leetcode [122] Best Time to Buy and Sell Stock II）
  思路：在价格曲线图中，曲线斜率大于0表示有利润，曲线斜率小于0表示亏本，在可以买卖无数次的情况下，只要斜率大于0就交易，即只要价格大于前一天就买，就算后一天
  价格大于今天利润更大也可以今天买了之后再买入，利润是不变的
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int profits = 0;
          for (int i = 1; i < prices.length; ++i) {
              int temp = prices[i] - prices[i-1];
              if (temp > 0) {
                  profits += temp;
              }
          }
          return profits;
      }
  }
  
2.2.3.股票可以买卖两次（leetcode [123] Best Time to Buy and Sell Stock III）
  思路：结合当前卖出能赚的利润(最大利润)和当前买入能赚的利润(最大利润)
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int len = prices.length;
          // 当前卖出能赚的利润(最大利润)
          int[] dp1 = new int[len];
          // 当前买入能赚的利润(最大利润)
          int[] dp2 = new int[len];
          int minPrice = prices[0];
          for (int i = 1; i < len; ++i) {            
              dp1[i] = Math.max(prices[i] - minPrice, dp1[i-1]);
              minPrice = Math.min(minPrice, prices[i]);         
          }
          int maxPrice = prices[len-1];
          for (int i = len-2; i >= 0; --i) {           
              dp2[i] = Math.max(maxPrice - prices[i], dp2[i+1]);
              maxPrice = Math.max(maxPrice, prices[i]);          
          }
          int ans = 0;
          for (int i = 0; i < len; ++i) {
              ans = Math.max(ans, dp1[i] + dp2[i]);
          }
          return ans;
      }
  }

  


分割数组得到最大和（leetcode [1043] Partition Array for Maximum Sum）
  代码：
  class Solution {
      public int maxSumAfterPartitioning(int[] A, int K) {
          int len = A.length;
          int[] dp = new int[len + 1];
          for (int i = 0; i <= len; ++i) {      
              int max = Integer.MIN_VALUE;
              for (int j = i - 1; j >= 0 && i-j <= K; --j) {
                  max = Math.max(max, A[j]);
                  dp[i] = Math.max(dp[i], dp[j] + max * (i-j));
              }
          }
          return dp[len];
      }
  }


素数表自定义的丑数（leetcode [313] Super Ugly Number）
  参考：https://www.cnblogs.com/lightwindy/p/9758211.html
  代码：
  class Solution {
      public int nthSuperUglyNumber(int n, int[] primes) {
          int[] ugly = new int[n+1];
          int[] postions = new int[primes.length];
          ugly[0] = 1;
          for (int i = 1; i <= n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ugly[postions[j]] * primes[j]) {
                      minVal = ugly[postions[j]] * primes[j];
                      index = j;
                  } else if (minVal == ugly[postions[j]] * primes[j]) {
                      ++postions[j];
                  }
              }
              ugly[i] = minVal;
              ++postions[index];
          }
          return ugly[n-1];
      }
  }
丑数基本原型（leetcode [264] Ugly Number II）
  代码：
  class Solution {
      public int nthUglyNumber(int n) {
          int[] ans = new int[n];
          ans[0] = 1;
          int[] primes = {2, 3, 5};
          int[] pos = new int[primes.length];
          for (int i = 1; i < n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ans[pos[j]] * primes[j]) {
                      minVal = ans[pos[j]] * primes[j];
                      index = j;
                  } else if (minVal == ans[pos[j]] * primes[j]) {
                      ++pos[j];
                  }                
              }
              ++pos[index];
              ans[i] = minVal;
          }
          return ans[n-1];
      }
  }
