1.基础知识
1.1.基础：https://juejin.im/post/5d1418a5e51d45108c59a57c#heading-2
1.2.背包九讲：https://www.kancloud.cn/kancloud/pack/70125
1.3.背包九讲java实现：https://www.zhihu.com/people/liu-xun-39-54/posts
1.4.最长公共子序列和最长公共子串(最长共同子序列)：https://www.cnblogs.com/en-heng/p/3963803.html

2.1.数的除法
2.1.1.除数博弈（leetcode [1025] Divisor Game）
  代码：
  class Solution {
      public boolean divisorGame(int N) {
          // 最优的数不是最大的约数，而是能找到的让自己立于不败之地的最合适的数
          if (N <= 1) {
              return false;
          }
          boolean[] dp = new boolean[N+1];
          dp[1] = false;
          dp[2] = true;
          for (int i = 3; i <= N; ++i) {
              for (int j = 1; j < i; ++j) {
                  if (i%j==0 && !dp[i-j]) {
                      dp[i] = true;
                      break;
                  }
              }
          }
          return dp[N];
      }

  }


分割数组得到最大和（leetcode [1043] Partition Array for Maximum Sum）
  代码：
  class Solution {
      public int maxSumAfterPartitioning(int[] A, int K) {
          int len = A.length;
          int[] dp = new int[len + 1];
          for (int i = 0; i <= len; ++i) {      
              int max = Integer.MIN_VALUE;
              for (int j = i - 1; j >= 0 && i-j <= K; --j) {
                  max = Math.max(max, A[j]);
                  dp[i] = Math.max(dp[i], dp[j] + max * (i-j));
              }
          }
          return dp[len];
      }
  }


素数表自定义的丑数（leetcode [313] Super Ugly Number）
  参考：https://www.cnblogs.com/lightwindy/p/9758211.html
  代码：
  class Solution {
      public int nthSuperUglyNumber(int n, int[] primes) {
          int[] ugly = new int[n+1];
          int[] postions = new int[primes.length];
          ugly[0] = 1;
          for (int i = 1; i <= n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ugly[postions[j]] * primes[j]) {
                      minVal = ugly[postions[j]] * primes[j];
                      index = j;
                  } else if (minVal == ugly[postions[j]] * primes[j]) {
                      ++postions[j];
                  }
              }
              ugly[i] = minVal;
              ++postions[index];
          }
          return ugly[n-1];
      }
  }
丑数基本原型（leetcode [264] Ugly Number II）
  代码：
  class Solution {
      public int nthUglyNumber(int n) {
          int[] ans = new int[n];
          ans[0] = 1;
          int[] primes = {2, 3, 5};
          int[] pos = new int[primes.length];
          for (int i = 1; i < n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ans[pos[j]] * primes[j]) {
                      minVal = ans[pos[j]] * primes[j];
                      index = j;
                  } else if (minVal == ans[pos[j]] * primes[j]) {
                      ++pos[j];
                  }                
              }
              ++pos[index];
              ans[i] = minVal;
          }
          return ans[n-1];
      }
  }
