1.基础知识
1.1.基础：https://juejin.im/post/5d1418a5e51d45108c59a57c#heading-2
1.2.背包九讲：https://www.kancloud.cn/kancloud/pack/70125
1.3.背包九讲java实现：https://www.zhihu.com/people/liu-xun-39-54/posts
1.4.最长公共子序列和最长公共子串(最长共同子序列)：https://www.cnblogs.com/en-heng/p/3963803.html

2.1.数
2.1.1.除数博弈（leetcode [1025] Divisor Game）
  代码：
  class Solution {
      public boolean divisorGame(int N) {
          // 最优的数不是最大的约数，而是能找到的让自己立于不败之地的最合适的数
          if (N <= 1) {
              return false;
          }
          boolean[] dp = new boolean[N+1];
          dp[1] = false;
          dp[2] = true;
          for (int i = 3; i <= N; ++i) {
              for (int j = 1; j < i; ++j) {
                  if (i%j==0 && !dp[i-j]) {
                      dp[i] = true;
                      break;
                  }
              }
          }
          return dp[N];
      }

  }
2.1.2.数的比特位1的个数（leetcode [338] Counting Bits）
  代码：
  class Solution {
      public int[] countBits(int num) {
          int[] dp = new int[num + 1];
          dp[0] = 0;
          if (num >= 1) {
              dp[1] = 1;
              for (int i = 2; i <= num; ++i) {
                  dp[i] = dp[i >> 1] + (i&1);
              }
          }
          return dp;
      }
  }
  
2.2.股票买卖
2.2.1.股票只能买卖一次（leetcode [121] Best Time to Buy and Sell Stock）
  思路：在价格曲线图中，纵轴差值的绝对值表示盈利或者亏本的金额，买卖一次，最大利润即为找盈利情况下的最大差值
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int maxProfit = 0;
          int minPrice = prices[0];
          for (int i = 1; i < prices.length; ++i) {
              int tempProfit = prices[i] - minPrice > 0 ? prices[i] - minPrice : 0;
              maxProfit = Math.max(maxProfit, tempProfit);
              minPrice = Math.min(minPrice, prices[i]);

          }
          return maxProfit;
      }
  }
  
2.2.2.股票可以买卖无数次（leetcode [122] Best Time to Buy and Sell Stock II）
  思路：在价格曲线图中，曲线斜率大于0表示有利润，曲线斜率小于0表示亏本，在可以买卖无数次的情况下，只要斜率大于0就交易，即只要价格大于前一天就买，就算后一天
  价格大于今天利润更大也可以今天买了之后再买入，利润是不变的
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int profits = 0;
          for (int i = 1; i < prices.length; ++i) {
              int temp = prices[i] - prices[i-1];
              if (temp > 0) {
                  profits += temp;
              }
          }
          return profits;
      }
  }
  
2.2.3.股票可以买卖两次（leetcode [123] Best Time to Buy and Sell Stock III）
  思路：结合当前卖出能赚的利润(最大利润)和当前买入能赚的利润(最大利润)
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int len = prices.length;
          // 当前卖出能赚的利润(最大利润)
          int[] dp1 = new int[len];
          // 当前买入能赚的利润(最大利润)
          int[] dp2 = new int[len];
          int minPrice = prices[0];
          for (int i = 1; i < len; ++i) {            
              dp1[i] = Math.max(prices[i] - minPrice, dp1[i-1]);
              minPrice = Math.min(minPrice, prices[i]);         
          }
          int maxPrice = prices[len-1];
          for (int i = len-2; i >= 0; --i) {           
              dp2[i] = Math.max(maxPrice - prices[i], dp2[i+1]);
              maxPrice = Math.max(maxPrice, prices[i]);          
          }
          int ans = 0;
          for (int i = 0; i < len; ++i) {
              ans = Math.max(ans, dp1[i] + dp2[i]);
          }
          return ans;
      }
  }
2.2.4.股票可以买卖k次（leetcode [188] Best Time to Buy and Sell Stock IV）
  思路：当k >= len/2时，问题就退化成了可以交易任意次了，所以只要将任意两天股票差大于０的加起来即可．当k < len/2时，可以记录k次交易每次买之后和卖以后
最大的利润：１．第ｉ次买操作买下当前股票之后剩下的最大利润为第(i-1)次卖掉股票之后的利润－当前的股票价格．状态转移方程为：
                buy[i] = max(sell[i-1]- curPrice, buy[i]);
          ２．第ｉ次卖操作卖掉当前股票之后剩下的最大利润为第ｉ次买操作之后剩下的利润＋当前股票价格．状态转移方程为：
                sell[i] = max(buy[i]+curPrice, sell[i]);
  
  代码：
  class Solution {
      public int maxProfit(int k, int[] prices) {
          int len = prices.length;
          if (k >= len/2) {
              int profit = 0;
              for (int i = 1; i < len; ++i) {
                  if (prices[i] > prices[i-1]) {
                      profit += prices[i] - prices[i-1];
                  }
              }
              return profit;
          }        
          int[] buy = new int[k+1];
          int[] sell = new int[k+1];
          // buy数组初始化为整数最小值是为了确保每件商品购入时最大利润不为0
          Arrays.fill(buy, Integer.MIN_VALUE);
          // 从每件商品开始
          for (int price : prices) {
              for (int i = 1; i <= k; ++i) {
                  buy[i] = Math.max(buy[i], sell[i-1] - price);
                  sell[i] = Math.max(sell[i], buy[i] + price);
              }
          }
          return sell[k];
      }
  }
2.2.5.股票买卖(无限次)含冷冻期（leetcode [309] Best Time to Buy and Sell Stock with Cooldown）
  思路：
  考虑第i天不持有dp[i][0]和持有dp[i][1]的转移方程：
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i])
    dp[i][1]=max(dp[i-1][1],dp[i-2][0]-p[i])
  压缩
    可以对i这个属性进行压缩，但是计算i需要i-1和i-2的信息，所以至少需要三行记录（类似斐波那契求解）
    cur[1]=max(bf1[1],bf2[0]-p[i])
    cur[0]=max(bf1[0],bf1[1]+p[i])
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int[] cur = new int[2];
          int[] bf1 = new int[2];
          int[] bf2 = new int[2];
          bf1[0] = 0;
          bf1[1] = -prices[0];
          bf2[0] = 0;
          for (int i = 1; i < prices.length; ++i) {
              cur[0] = Math.max(bf1[1] + prices[i], bf1[0]);
              cur[1] = Math.max(bf2[0] - prices[i], bf1[1]);
              bf2[0] = bf1[0];
              bf2[1] = bf1[1];
              bf1[0] = cur[0];
              bf1[1] = cur[1];
          }
          return cur[0];
      }
  }
2.2.6.股票买卖(无限次)含手续费（leetcode [714] Best Time to Buy and Sell Stock with Transaction Fee）
  思路：
  考虑第i天不持有dp[i][0]和持有dp[i][1]的转移方程：
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i])
    dp[i][1]=max(dp[i-1][1],dp[i-1][0]-p[i]-fee)
  压缩
    可以对i这个属性进行压缩，但是计算i需要i-1和i-2的信息，所以至少需要三行记录（类似斐波那契求解）
    cur[0] = max(bf1[0], bf1[1] + prices[i])
    cur[1] = max(bf1[1], bf1[0] - prices[i] - fee)
  代码：
  class Solution {
      public int maxProfit(int[] prices, int fee) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int[] bf1 = new int[2];
          int[] cur = new int[2];
          bf1[0] = 0;
          bf1[1] = -prices[0] - fee;
          for (int i = 1; i < prices.length; ++i) {
              cur[0] = Math.max(bf1[0], bf1[1] + prices[i]);
              cur[1] = Math.max(bf1[1], bf1[0] - prices[i] - fee);
              bf1[0] = cur[0];
              bf1[1] = cur[1];
          }
          return cur[0];
      }
  }
  
2.3.斐波那契类型
2.3.1.爬楼梯的最小代价（leetcode [746] Min Cost Climbing Stairs）
  代码：
  class Solution {
      public int minCostClimbingStairs(int[] cost) {
          if (cost.length == 2) {
              return Math.min(cost[0], cost[1]);
          }
          // dp[i] = min{dp[i-1], dp[i-2]} + cost[i]
          int a = cost[0];
          int b = cost[1];
          int c = 0;
          for (int i = 2; i < cost.length; ++i) {
              c = Math.min(a, b) + cost[i];
              a = b;
              b = c;

          }
          return Math.min(a, b);
      }
  }
2.3.2.爬楼梯的方案总数（leetcode [70] Climbing Stairs）
  代码：
  class Solution {
      public int climbStairs(int n) {
          int a = 1;
          int b = 2;
          if (n < 1) {
              return 0;
          }
          if (n == 1) {
              return a;
          }
          if (n == 2) {
              return b;
          }
          int c = 0;
          // dp[i] = dp[i-1] + dp[i-2]
          for (int i = 3; i <= n; ++i) {
              c = a + b;
              a = b;
              b = c;
          }
          return c;
      }
  }
  
2.4.序列中的dp
2.4.1.最大连续子序和（leetcode [53] Maximum Subarray）
  代码：
  class Solution {
      public int maxSubArray(int[] nums) {
          if (nums == null || nums.length == 0) {
              return 0;
          }
          int a = nums[0];
          int b = 0;
          int ans = a;
          // dp[i]表示以结尾的最大连续子序和
          // dp[i] = max{dp[i-1]+nums[i], nums[i]}
          for (int i = 1; i < nums.length; ++i) {
              b = Math.max(a + nums[i], nums[i]);
              ans = Math.max(b, ans);
              a = b;
          }
          return ans;
      }
  }
2.4.2.矩阵的前序和（leetcode 1314. Matrix Block Sum）
  代码：
  class Solution {
      public int[][] matrixBlockSum(int[][] mat, int K) {
          int m = mat.length;
          int n = mat[0].length;
          int[][] sums = new int[m+1][n+1];
          int[][] ans = new int[m][n];
          for (int i = 1; i <= m; ++i) {
              for (int j = 1; j <= n; ++j) {
                  sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + mat[i-1][j-1];
              }
          }
          int k = K;
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  int x1 = Math.min(i+k+1, m);
                  int y1 = Math.min(j+k+1, n);
                  int x0 = Math.max(i-k, 0);
                  int y0 = Math.max(j-k, 0);
                  ans[i][j] = sums[x1][y1] + sums[x0][y0] - sums[x1][y0] - sums[x0][y1];
              }
          }
          return ans;
      }
  }
矩阵类相关之正方形个数计算问题（leetcode 1277. Count Square Submatrices with All Ones）
  代码：
  class Solution {
      public int countSquares(int[][] matrix) {
          int m = matrix.length;
          int n = matrix[0].length;
          int[][] sums = new int[m+1][n+1];
          int ans = 0;
          int th = Math.min(m, n);
          for (int i = 1; i <= m; ++i) {
              for (int j = 1; j <= n; ++j) {
                  sums[i][j] = matrix[i-1][j-1] + sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1];
                  for (int t = 1; t <= th; ++t) {
                      int x0 = Math.max(i-t, 0);
                      int y0 = Math.max(j-t, 0);
                      if (sums[i][j] - sums[x0][j] - sums[i][y0] + sums[x0][y0] != t*t) {
                          break;
                      }
                      ++ans;
                  }
              }
          }
          return ans;
      }
  }
  
2.5.小偷偷盗问题
2.5.1.普通小偷偷盗问题（leetcode [198] House Robber）
  代码：
  class Solution {
      public int rob(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          /*
          int bf0 = 0;
          int bf1 = nums[0];
          int cur0 = bf0;
          int cur1 = bf1;
          // dp[i][0] = max{dp[i-1][0], dp[i-1][1]}
          // dp[i][1] = dp[i-1][0] + nums[i]
          for (int i = 1; i < nums.length; ++i) {
              cur0 = Math.max(bf0, bf1);
              cur1 = bf0 + nums[i];
              bf0 = cur0;
              bf1 = cur1;
          }
          return Math.max(cur0, cur1);
          */
          if (nums.length == 1) {
              return nums[0];
          }
          int a = nums[0];
          int b = Math.max(nums[0], nums[1]);
          int c = b;
          // dp[i] = max{nums[i] + dp[i-2], dp[i-1]}
          // dp[i]表示偷到第i家能获得的最大利润
          for (int i = 2; i < nums.length; ++i) {
              c = Math.max(nums[i] + a, b);
              a = b;
              b = c;
          }
          return c;
      }
  }
2.5.2.小偷偷盗成环问题（leetcode [213] House Robber II）
  代码：
  class Solution {
      public int rob(int[] nums) {
          if (nums == null || nums.length == 0) {
              return 0;
          }
          if (nums.length == 1) {
              return nums[0];
          }
          if (nums.length == 2) {
              return Math.max(nums[0], nums[1]);
          }
          if (nums.length == 3) {
              return Math.max(Math.max(nums[0], nums[2]), nums[1]);
          }
          // 从第1个房子偷到第n-1个房子的最大值
          int a1 = nums[0];
          int b1 = Math.max(nums[1], nums[0]);
          int c1 = b1;
          for (int i = 2; i < nums.length - 1; ++i) {
              c1 = Math.max(nums[i] + a1, b1);
              a1 = b1;
              b1 = c1;
          }
          // 从第2个房子偷到第n个房子的最大值
          int a2 = nums[1];
          int b2 = Math.max(nums[2], nums[1]);
          int c2 = b2;
          for (int i = 3; i < nums.length; ++i) {
              c2 = Math.max(nums[i] + a2, b2);
              a2 = b2;
              b2 = c2;
          }
          return Math.max(c1, c2);
      }
  }
2.5.3.偷盗成树问题（leetcode [337] House Robber III）
  代码：
  class Solution {

      public class Point{
          int c0;
          int c1;
          public Point(int x, int y){
              c0 = x;
              c1 = y;
          }
      }

      public Point dfs (TreeNode node) {
          if (node == null ) {
              return new Point(0, 0);
          }
          // 0表示到不偷该节点的以该节点为根的最大偷盗和
          // 1表示到偷该节点的以该节点为根的最大偷盗和
          // root[0] = max{left[0], left[1]} + max{right[0], right[1]}
          // root[1] = root.val + left[0] + right[0]
          Point left = dfs(node.left);
          Point right = dfs(node.right);
          int c0 = Math.max(left.c0, left.c1) + Math.max(right.c0, right.c1);
          int c1 = node.val + left.c0 + right.c0;
          return new Point(c0, c1);
      }

      public int rob(TreeNode root) {
          Point ans  = dfs(root);
          return Math.max(ans.c0, ans.c1);
      }
  }


分割数组得到最大和（leetcode [1043] Partition Array for Maximum Sum）
  代码：
  class Solution {
      public int maxSumAfterPartitioning(int[] A, int K) {
          int len = A.length;
          int[] dp = new int[len + 1];
          for (int i = 0; i <= len; ++i) {      
              int max = Integer.MIN_VALUE;
              for (int j = i - 1; j >= 0 && i-j <= K; --j) {
                  max = Math.max(max, A[j]);
                  dp[i] = Math.max(dp[i], dp[j] + max * (i-j));
              }
          }
          return dp[len];
      }
  }


素数表自定义的丑数（leetcode [313] Super Ugly Number）
  参考：https://www.cnblogs.com/lightwindy/p/9758211.html
  代码：
  class Solution {
      public int nthSuperUglyNumber(int n, int[] primes) {
          int[] ugly = new int[n+1];
          int[] postions = new int[primes.length];
          ugly[0] = 1;
          for (int i = 1; i <= n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ugly[postions[j]] * primes[j]) {
                      minVal = ugly[postions[j]] * primes[j];
                      index = j;
                  } else if (minVal == ugly[postions[j]] * primes[j]) {
                      ++postions[j];
                  }
              }
              ugly[i] = minVal;
              ++postions[index];
          }
          return ugly[n-1];
      }
  }
丑数基本原型（leetcode [264] Ugly Number II）
  代码：
  class Solution {
      public int nthUglyNumber(int n) {
          int[] ans = new int[n];
          ans[0] = 1;
          int[] primes = {2, 3, 5};
          int[] pos = new int[primes.length];
          for (int i = 1; i < n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ans[pos[j]] * primes[j]) {
                      minVal = ans[pos[j]] * primes[j];
                      index = j;
                  } else if (minVal == ans[pos[j]] * primes[j]) {
                      ++pos[j];
                  }                
              }
              ++pos[index];
              ans[i] = minVal;
          }
          return ans[n-1];
      }
  }


