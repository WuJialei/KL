1.基础知识
1.1.基础：https://juejin.im/post/5d1418a5e51d45108c59a57c#heading-2
1.2.背包九讲：https://www.kancloud.cn/kancloud/pack/70125
1.3.背包九讲java实现：https://www.zhihu.com/people/liu-xun-39-54/posts
1.4.最长公共子序列和最长公共子串(最长共同子序列)：https://www.cnblogs.com/en-heng/p/3963803.html

2.1.数的除法
2.1.1.除数博弈（leetcode [1025] Divisor Game）
  代码：
  class Solution {
      public boolean divisorGame(int N) {
          // 最优的数不是最大的约数，而是能找到的让自己立于不败之地的最合适的数
          if (N <= 1) {
              return false;
          }
          boolean[] dp = new boolean[N+1];
          dp[1] = false;
          dp[2] = true;
          for (int i = 3; i <= N; ++i) {
              for (int j = 1; j < i; ++j) {
                  if (i%j==0 && !dp[i-j]) {
                      dp[i] = true;
                      break;
                  }
              }
          }
          return dp[N];
      }

  }
  
2.2.股票买卖
2.2.1.股票只能买卖一次（leetcode [121] Best Time to Buy and Sell Stock）
  思路：在价格曲线图中，纵轴差值的绝对值表示盈利或者亏本的金额，买卖一次，最大利润即为找盈利情况下的最大差值
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int maxProfit = 0;
          int minPrice = prices[0];
          for (int i = 1; i < prices.length; ++i) {
              int tempProfit = prices[i] - minPrice > 0 ? prices[i] - minPrice : 0;
              maxProfit = Math.max(maxProfit, tempProfit);
              minPrice = Math.min(minPrice, prices[i]);

          }
          return maxProfit;
      }
  }
  
2.2.2.股票可以买卖无数次（leetcode [122] Best Time to Buy and Sell Stock II）
  思路：在价格曲线图中，曲线斜率大于0表示有利润，曲线斜率小于0表示亏本，在可以买卖无数次的情况下，只要斜率大于0就交易，即只要价格大于前一天就买，就算后一天
  价格大于今天利润更大也可以今天买了之后再买入，利润是不变的
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int profits = 0;
          for (int i = 1; i < prices.length; ++i) {
              int temp = prices[i] - prices[i-1];
              if (temp > 0) {
                  profits += temp;
              }
          }
          return profits;
      }
  }
  
2.2.3.股票可以买卖两次（leetcode [123] Best Time to Buy and Sell Stock III）
  思路：结合当前卖出能赚的利润(最大利润)和当前买入能赚的利润(最大利润)
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int len = prices.length;
          // 当前卖出能赚的利润(最大利润)
          int[] dp1 = new int[len];
          // 当前买入能赚的利润(最大利润)
          int[] dp2 = new int[len];
          int minPrice = prices[0];
          for (int i = 1; i < len; ++i) {            
              dp1[i] = Math.max(prices[i] - minPrice, dp1[i-1]);
              minPrice = Math.min(minPrice, prices[i]);         
          }
          int maxPrice = prices[len-1];
          for (int i = len-2; i >= 0; --i) {           
              dp2[i] = Math.max(maxPrice - prices[i], dp2[i+1]);
              maxPrice = Math.max(maxPrice, prices[i]);          
          }
          int ans = 0;
          for (int i = 0; i < len; ++i) {
              ans = Math.max(ans, dp1[i] + dp2[i]);
          }
          return ans;
      }
  }
2.2.4.股票可以买卖k次（leetcode [188] Best Time to Buy and Sell Stock IV）
  思路：当k >= len/2时，问题就退化成了可以交易任意次了，所以只要将任意两天股票差大于０的加起来即可．当k < len/2时，可以记录k次交易每次买之后和卖以后
最大的利润：１．第ｉ次买操作买下当前股票之后剩下的最大利润为第(i-1)次卖掉股票之后的利润－当前的股票价格．状态转移方程为：
                buy[i] = max(sell[i-1]- curPrice, buy[i]);
          ２．第ｉ次卖操作卖掉当前股票之后剩下的最大利润为第ｉ次买操作之后剩下的利润＋当前股票价格．状态转移方程为：
                sell[i] = max(buy[i]+curPrice, sell[i]);
  
  代码：
  class Solution {
      public int maxProfit(int k, int[] prices) {
          int len = prices.length;
          if (k >= len/2) {
              int profit = 0;
              for (int i = 1; i < len; ++i) {
                  if (prices[i] > prices[i-1]) {
                      profit += prices[i] - prices[i-1];
                  }
              }
              return profit;
          }        
          int[] buy = new int[k+1];
          int[] sell = new int[k+1];
          // buy数组初始化为整数最小值是为了确保每件商品购入时最大利润不为0
          Arrays.fill(buy, Integer.MIN_VALUE);
          // 从每件商品开始
          for (int price : prices) {
              for (int i = 1; i <= k; ++i) {
                  buy[i] = Math.max(buy[i], sell[i-1] - price);
                  sell[i] = Math.max(sell[i], buy[i] + price);
              }
          }
          return sell[k];
      }
  }
2.2.5.股票买卖(无限次)含冷冻期（leetcode [309] Best Time to Buy and Sell Stock with Cooldown）
  思路：
  考虑第i天不持有dp[i][0]和持有dp[i][1]的转移方程：
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i])
    dp[i][1]=max(dp[i-1][1],dp[i-2][0]-p[i])
  压缩
    可以对i这个属性进行压缩，但是计算i需要i-1和i-2的信息，所以至少需要三行记录（类似斐波那契求解）
    cur[1]=max(bf1[1],bf2[0]-p[i])
    cur[0]=max(bf1[0],bf1[1]+p[i])
  代码：
  class Solution {
      public int maxProfit(int[] prices) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int[] cur = new int[2];
          int[] bf1 = new int[2];
          int[] bf2 = new int[2];
          bf1[0] = 0;
          bf1[1] = -prices[0];
          bf2[0] = 0;
          for (int i = 1; i < prices.length; ++i) {
              cur[0] = Math.max(bf1[1] + prices[i], bf1[0]);
              cur[1] = Math.max(bf2[0] - prices[i], bf1[1]);
              bf2[0] = bf1[0];
              bf2[1] = bf1[1];
              bf1[0] = cur[0];
              bf1[1] = cur[1];
          }
          return cur[0];
      }
  }
2.2.6.股票买卖(无限次)含手续费（leetcode [714] Best Time to Buy and Sell Stock with Transaction Fee）
  思路：
  考虑第i天不持有dp[i][0]和持有dp[i][1]的转移方程：
    dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i])
    dp[i][1]=max(dp[i-1][1],dp[i-1][0]-p[i]-fee)
  压缩
    可以对i这个属性进行压缩，但是计算i需要i-1和i-2的信息，所以至少需要三行记录（类似斐波那契求解）
    cur[0] = max(bf1[0], bf1[1] + prices[i])
    cur[1] = max(bf1[1], bf1[0] - prices[i] - fee)
  代码：
  class Solution {
      public int maxProfit(int[] prices, int fee) {
          if (prices == null || prices.length <= 1) {
              return 0;
          }
          int[] bf1 = new int[2];
          int[] cur = new int[2];
          bf1[0] = 0;
          bf1[1] = -prices[0] - fee;
          for (int i = 1; i < prices.length; ++i) {
              cur[0] = Math.max(bf1[0], bf1[1] + prices[i]);
              cur[1] = Math.max(bf1[1], bf1[0] - prices[i] - fee);
              bf1[0] = cur[0];
              bf1[1] = cur[1];
          }
          return cur[0];
      }
  }

分割数组得到最大和（leetcode [1043] Partition Array for Maximum Sum）
  代码：
  class Solution {
      public int maxSumAfterPartitioning(int[] A, int K) {
          int len = A.length;
          int[] dp = new int[len + 1];
          for (int i = 0; i <= len; ++i) {      
              int max = Integer.MIN_VALUE;
              for (int j = i - 1; j >= 0 && i-j <= K; --j) {
                  max = Math.max(max, A[j]);
                  dp[i] = Math.max(dp[i], dp[j] + max * (i-j));
              }
          }
          return dp[len];
      }
  }


素数表自定义的丑数（leetcode [313] Super Ugly Number）
  参考：https://www.cnblogs.com/lightwindy/p/9758211.html
  代码：
  class Solution {
      public int nthSuperUglyNumber(int n, int[] primes) {
          int[] ugly = new int[n+1];
          int[] postions = new int[primes.length];
          ugly[0] = 1;
          for (int i = 1; i <= n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ugly[postions[j]] * primes[j]) {
                      minVal = ugly[postions[j]] * primes[j];
                      index = j;
                  } else if (minVal == ugly[postions[j]] * primes[j]) {
                      ++postions[j];
                  }
              }
              ugly[i] = minVal;
              ++postions[index];
          }
          return ugly[n-1];
      }
  }
丑数基本原型（leetcode [264] Ugly Number II）
  代码：
  class Solution {
      public int nthUglyNumber(int n) {
          int[] ans = new int[n];
          ans[0] = 1;
          int[] primes = {2, 3, 5};
          int[] pos = new int[primes.length];
          for (int i = 1; i < n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ans[pos[j]] * primes[j]) {
                      minVal = ans[pos[j]] * primes[j];
                      index = j;
                  } else if (minVal == ans[pos[j]] * primes[j]) {
                      ++pos[j];
                  }                
              }
              ++pos[index];
              ans[i] = minVal;
          }
          return ans[n-1];
      }
  }


