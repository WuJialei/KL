
分割数组得到最大和（leetcode [1043] Partition Array for Maximum Sum）
  代码：
  class Solution {
      public int maxSumAfterPartitioning(int[] A, int K) {
          int len = A.length;
          int[] dp = new int[len + 1];
          for (int i = 0; i <= len; ++i) {      
              int max = Integer.MIN_VALUE;
              for (int j = i - 1; j >= 0 && i-j <= K; --j) {
                  max = Math.max(max, A[j]);
                  dp[i] = Math.max(dp[i], dp[j] + max * (i-j));
              }
          }
          return dp[len];
      }
  }


素数表自定义的丑数（leetcode [313] Super Ugly Number）
  参考：https://www.cnblogs.com/lightwindy/p/9758211.html
  代码：
  class Solution {
      public int nthSuperUglyNumber(int n, int[] primes) {
          int[] ugly = new int[n+1];
          int[] postions = new int[primes.length];
          ugly[0] = 1;
          for (int i = 1; i <= n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ugly[postions[j]] * primes[j]) {
                      minVal = ugly[postions[j]] * primes[j];
                      index = j;
                  } else if (minVal == ugly[postions[j]] * primes[j]) {
                      ++postions[j];
                  }
              }
              ugly[i] = minVal;
              ++postions[index];
          }
          return ugly[n-1];
      }
  }
丑数基本原型（leetcode [264] Ugly Number II）
  代码：
  class Solution {
      public int nthUglyNumber(int n) {
          int[] ans = new int[n];
          ans[0] = 1;
          int[] primes = {2, 3, 5};
          int[] pos = new int[primes.length];
          for (int i = 1; i < n; ++i) {
              int minVal = Integer.MAX_VALUE;
              int index = 0;
              for (int j = 0; j < primes.length; ++j) {
                  if (minVal > ans[pos[j]] * primes[j]) {
                      minVal = ans[pos[j]] * primes[j];
                      index = j;
                  } else if (minVal == ans[pos[j]] * primes[j]) {
                      ++pos[j];
                  }                
              }
              ++pos[index];
              ans[i] = minVal;
          }
          return ans[n-1];
      }
  }
