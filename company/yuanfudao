1.参考：https://www.nowcoder.com/discuss/240129
2.具体
2.1.leetcode 189. 旋转数组
代码：
  class Solution {
      public void rotate(int[] nums, int k) {
          if (nums == null || nums.length < 1 || k <= 0) {
              return;
          }
          k = k % nums.length;
          /*
          while (k > 0) {
              int tmp = nums[nums.length-1];
              for (int i = nums.length-2; i >= 0; --i) {
                  nums[i+1] = nums[i];
              }
              nums[0] = tmp;
              --k;
          }
          */
          reverse(nums, 0, nums.length-1);
          reverse(nums, 0, k-1);
          reverse(nums, k, nums.length-1);
      }

      public void reverse(int[] nums, int start, int end) {
          if (start >= end) {
              return;
          }
          while (start < end) {
              int tmp = nums[start];
              nums[start] = nums[end];
              nums[end] = tmp;
              ++start;
              --end;
          }
      }

  }
  
2.2.leetcode 1. 两数之和
代码：
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          if (nums == null || nums.length < 2) {
              return new int[0];
          }
          HashMap<Integer, List<Integer>> map = new HashMap<>();
          for (int i = 0; i < nums.length; ++i) {
              if (!map.containsKey(nums[i])) {
                  map.put(nums[i], new ArrayList<>());
              }
              map.get(nums[i]).add(i);
          }
          for (int i = 0; i < nums.length; ++i) {
              int val = nums[i];
              if (map.containsKey(target - val)) {
                  for (int index : map.get(target-val)) {
                      if (index != i) {
                          return new int[]{i, index};
                      }
                  }
              }
          }
          return new int[0];
          // int[] ans = {left, right};
          // return ans;

      }
  }
  
2.3.leetcode 面试题 03.05. 栈排序
代码：
  class SortedStack {

      private Stack<Integer> stack;

      public SortedStack() {
          stack = new Stack<>();
      }

      public void push(int val) {
          if (stack.isEmpty()) {
              stack.push(val);
          } else {
              Stack<Integer> tmp = new Stack<>();
              while (!stack.isEmpty()) {
                  if (stack.peek() < val) {
                      tmp.push(stack.pop());
                  } else {
                      break;
                  }
              }
              stack.push(val);
              while(!tmp.isEmpty()){
                  stack.push(tmp.pop());
              }
          }

      }

      public void pop() {
          if (stack.isEmpty()) {
              return;
          }
          stack.pop();
      }

      public int peek() {
          if (stack.isEmpty()) {
              return -1;
          }
          return stack.peek();
      }

      public boolean isEmpty() {
          return stack.isEmpty();
      }
  }
  
2.4.leetcode 222. 完全二叉树的节点个数
代码：
  class Solution {

      public int cntNum(int k) {
          if (k == 0) {
              return 1;
          }
          if (k == 1) {
              return 2;
          }
          int val = cntNum(k/2);
          if (k%2 == 0) {
              return val * val;
          } else {
              return val * val * 2;
          }

      }

      public int height (TreeNode node) {
          if (node == null) {
              return 0;
          }
          return 1 + Math.max(height(node.left), height(node.right));
      }

      public int countNodes(TreeNode root) {
          if (root == null) {
              return 0;
          }
          int lH = height(root.left);
          int rH= height(root.right);
          if (lH > rH) {
              // return countNodes(root.left) + cntNum(rH);
              return countNodes(root.left) + (1 << rH);
          } else {
              // return countNodes(root.right) + cntNum(lH);
              return countNodes(root.right) + (1 << lH);
          }
      }
  }
  
2.5.leetcode 剑指 Offer 36. 二叉搜索树与双向链表
代码：
  class Solution {

      private Node head;
      private Node last;

      public Node treeToDoublyList(Node root) {
          if (root == null) {
              return null;
          }
          dfs(root);
          head.left = last;
          last.right = head;
          return head;
      }

      public void dfs (Node node) {
          if (node == null) {
              return;
          }
          // inorder
          dfs(node.left);
          if (last != null) {
              last.right = node;
          } else {
              head = node;
          }
          node.left = last;
          last = node;
          dfs(node.right);

      }

  }
  
2.6.leetcode 98. 验证二叉搜索树
代码：
  /*
  class Solution {
    
      TreeNode pre;

      public boolean isValidBST(TreeNode root) {
          if (root == null) {
              return true;
          }
          if (!isValidBST(root.left)) {
              return false;
          }
          if (pre != null && pre.val >= root.val) {
              return false;
          }
          pre = root;
          return isValidBST(root.right);
      }
  }
  */
  class Solution {

      public boolean dfs (TreeNode node, int val, int flag) {
          if (node == null) {
              return true;
          }
          if (flag == 0) {
              if (node.val >= val) {
                  return false;
              }
          } else {
              if (node.val <= val) {
                  return false;
              }
          }
          return dfs(node.left, val, flag) && dfs(node.right, val, flag);
      }

      public boolean isValidBST(TreeNode root) {
          if (root == null) {
              return true;
          }
          if (!dfs(root.left, root.val, 0) || !dfs(root.right, root.val, 1)) {
              return false;
          }
          return isValidBST(root.left) && isValidBST(root.right);
      }
  }
