1.两数之和（leetcode 1）
  代码：
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          if (nums == null || nums.length < 2) {
              return new int[0];
          }
          HashMap<Integer, Integer> map = new HashMap<>();
          for (int i = 0; i < nums.length; ++i) {
              if (map.containsKey(target - nums[i])) {
                  return new int[]{map.get(target - nums[i]), i};
              }
              map.put(nums[i], i);
          }
          return new int[0];
      }
  }
  
2.字符串转换整数 (leetcode 8)
  代码：
  class Solution {
      public int myAtoi(String str) {
          if (str == null || str.length() < 1) {
              return 0;
          }
          str = str.trim();
          if (str.length() < 1) {
              return 0;
          }
          int sign = 1;
          int index = 0;
          if (str.charAt(index) == '-') {
              sign = -1;
              ++index;
          } else if (str.charAt(index) == '+') {
              ++index;
          } else if (str.charAt(index) < '0' || str.charAt(index) > '9') {
              return 0;
          }
          while (index < str.length() && str.charAt(index) == '0') {
              ++index;
              if (index == str.length()) {
                  return 0;
              }
          }
          String tmp = str.substring(index, str.length());
          int ans = 0;
          for (int i = 0; i < tmp.length(); ++i) {
              int cur = tmp.charAt(i) - '0';
              if (cur < 0 || cur > 9) {
                  break;
              }
              if (ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE/10 && cur > Integer.MAX_VALUE%10)) {
                  return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
              }
              ans = ans * 10 + cur;
          }
          return sign * ans;
      }
  }

3.翻转字符串里的单词 II（leetcode 186）
  代码：
  class Solution {
    
      public void reverse(char[] s, int start, int end) {
          while (start < end) {
              char c = s[start];
              s[start] = s[end];
              s[end] = c;
              ++start;
              --end;
          }
      }

      public void reverseWords(char[] s) {
          if (s == null || s.length < 1) {
              return;
          }
          // 两次翻转，先全翻转，后每个单词翻转
          reverse(s, 0, s.length-1);
          int start = 0;
          for (int i = 0; i < s.length; ++i) {
              if (s[i] == ' ') {
                  reverse(s, start, i-1);
                  start = i+1;
              } 
          }
          reverse(s, start, s.length-1);
      }
  }
  
4.最长回文子串(leetcode 5)
  代码：
  class Solution {
      public String longestPalindrome(String s) {
          if (s == null || s.length() < 1) {
              return s;
          }
          int len = s.length();
          // dp[l][r] = true if dp[l+1][r-1] == true && s[l] == s[r]
          boolean[][] dp = new boolean[len][len];
          int maxLen = 1;
          int start = 0;
          int end = 0;
          for (int i = 0; i < len; ++i) {
              dp[i][i] = true;
          }
          for (int r = 0; r < len; ++r) {
              for (int l = 0; l < r; ++l) {
                  if (s.charAt(l) == s.charAt(r) && (r-l == 1 ||(r-l >= 2 && dp[l+1][r-1])) ){
                      dp[l][r] = true;
                      if (r-l+1 > maxLen) {
                          maxLen = r-l+1;
                          start = l;
                          end = r;
                      }
                  }
              }
          }
          return s.substring(start, end+1);
      }
  }

5.字母异位词分组(leetcode 49)
  代码：
  class Solution {

      public String method(String str) {
          StringBuilder sb = new StringBuilder("");
          int[] array = new int[26];
          for (char c : str.toCharArray()) {
              ++array[c-'a'];
          }
          for (int i = 0; i < 26; ++i) {
              while (array[i] > 0) {
                  sb.append('0' + i);
                  --array[i];
              }
          }
          return sb.toString();
      }

      public List<List<String>> groupAnagrams(String[] strs) {
          List<List<String>> ans = new ArrayList<>();
          if (strs == null || strs.length < 1) {
              return ans;
          }
          HashMap<String, List<Integer>> map = new HashMap<>();
          for (int i = 0; i < strs.length; ++i) {
              String str = method(strs[i]);
              if (!map.containsKey(str)) {
                  map.put(str, new ArrayList<Integer>());
              }
              map.get(str).add(i);
          }
          for (Map.Entry<String, List<Integer>> entry : map.entrySet()) {
              List<String> tmp = new ArrayList<>();
              for (int i : entry.getValue()) {
                  tmp.add(strs[i]);
              }
              ans.add(tmp);
          }
          return ans;
      }
  }

6.接雨水（leetcode 42. Trapping Rain Water）
  代码：
  class Solution {
      public int trap(int[] height) {
          if (height == null || height.length < 1) {
              return 0;
          }
          int len = height.length;
          // leftH[i]表示第i列左边最高高度，不包括第i列的高度
          // rightH[i]表示第i列右边最高高度，不包括第i列的高度
          // 根据木板效应，装水取决于最短木板，因此比较最短木板与当前水位看是否能够装水
          int[] left = new int[len];
          int[] right = new int[len];
          for (int i = 1; i < len; ++i) {
              left[i] = Math.max(height[i-1], left[i-1]);
          }
          for (int i = len-2; i >= 0; --i) {
              right[i] = Math.max(height[i+1], right[i+1]);
          }
          int ans = 0;
          for (int i = 1; i < len-1; ++i) {
              int tmp = Math.min(left[i], right[i]);
              if (tmp > height[i]) {
                  ans += tmp - height[i];
              }
          }
          return ans;
      }
  }
