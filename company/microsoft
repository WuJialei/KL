1.两数之和（leetcode 1）
  代码：
  class Solution {
      public int[] twoSum(int[] nums, int target) {
          if (nums == null || nums.length < 2) {
              return new int[0];
          }
          HashMap<Integer, Integer> map = new HashMap<>();
          for (int i = 0; i < nums.length; ++i) {
              if (map.containsKey(target - nums[i])) {
                  return new int[]{map.get(target - nums[i]), i};
              }
              map.put(nums[i], i);
          }
          return new int[0];
      }
  }
  
2.字符串转换整数 (leetcode 8)
  代码：
  class Solution {
      public int myAtoi(String str) {
          if (str == null || str.length() < 1) {
              return 0;
          }
          str = str.trim();
          if (str.length() < 1) {
              return 0;
          }
          int sign = 1;
          int index = 0;
          if (str.charAt(index) == '-') {
              sign = -1;
              ++index;
          } else if (str.charAt(index) == '+') {
              ++index;
          } else if (str.charAt(index) < '0' || str.charAt(index) > '9') {
              return 0;
          }
          while (index < str.length() && str.charAt(index) == '0') {
              ++index;
              if (index == str.length()) {
                  return 0;
              }
          }
          String tmp = str.substring(index, str.length());
          int ans = 0;
          for (int i = 0; i < tmp.length(); ++i) {
              int cur = tmp.charAt(i) - '0';
              if (cur < 0 || cur > 9) {
                  break;
              }
              if (ans > Integer.MAX_VALUE/10 || (ans == Integer.MAX_VALUE/10 && cur > Integer.MAX_VALUE%10)) {
                  return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
              }
              ans = ans * 10 + cur;
          }
          return sign * ans;
      }
  }

3.翻转字符串里的单词 II（leetcode 186）
  代码：
  class Solution {
    
      public void reverse(char[] s, int start, int end) {
          while (start < end) {
              char c = s[start];
              s[start] = s[end];
              s[end] = c;
              ++start;
              --end;
          }
      }

      public void reverseWords(char[] s) {
          if (s == null || s.length < 1) {
              return;
          }
          // 两次翻转，先全翻转，后每个单词翻转
          reverse(s, 0, s.length-1);
          int start = 0;
          for (int i = 0; i < s.length; ++i) {
              if (s[i] == ' ') {
                  reverse(s, start, i-1);
                  start = i+1;
              } 
          }
          reverse(s, start, s.length-1);
      }
  }
  
4.最长回文子串(leetcode 5)
  代码：
  class Solution {
      public String longestPalindrome(String s) {
          if (s == null || s.length() < 1) {
              return s;
          }
          int len = s.length();
          // dp[l][r] = true if dp[l+1][r-1] == true && s[l] == s[r]
          boolean[][] dp = new boolean[len][len];
          int maxLen = 1;
          int start = 0;
          int end = 0;
          for (int i = 0; i < len; ++i) {
              dp[i][i] = true;
          }
          for (int r = 0; r < len; ++r) {
              for (int l = 0; l < r; ++l) {
                  if (s.charAt(l) == s.charAt(r) && (r-l == 1 ||(r-l >= 2 && dp[l+1][r-1])) ){
                      dp[l][r] = true;
                      if (r-l+1 > maxLen) {
                          maxLen = r-l+1;
                          start = l;
                          end = r;
                      }
                  }
              }
          }
          return s.substring(start, end+1);
      }
  }

5.字母异位词分组(leetcode 49)
  代码：
  class Solution {

      public String method(String str) {
          StringBuilder sb = new StringBuilder("");
          int[] array = new int[26];
          for (char c : str.toCharArray()) {
              ++array[c-'a'];
          }
          for (int i = 0; i < 26; ++i) {
              while (array[i] > 0) {
                  sb.append('0' + i);
                  --array[i];
              }
          }
          return sb.toString();
      }

      public List<List<String>> groupAnagrams(String[] strs) {
          List<List<String>> ans = new ArrayList<>();
          if (strs == null || strs.length < 1) {
              return ans;
          }
          HashMap<String, List<Integer>> map = new HashMap<>();
          for (int i = 0; i < strs.length; ++i) {
              String str = method(strs[i]);
              if (!map.containsKey(str)) {
                  map.put(str, new ArrayList<Integer>());
              }
              map.get(str).add(i);
          }
          for (Map.Entry<String, List<Integer>> entry : map.entrySet()) {
              List<String> tmp = new ArrayList<>();
              for (int i : entry.getValue()) {
                  tmp.add(strs[i]);
              }
              ans.add(tmp);
          }
          return ans;
      }
  }

6.接雨水（leetcode 42. Trapping Rain Water）
  代码：
  class Solution {
      public int trap(int[] height) {
          if (height == null || height.length < 1) {
              return 0;
          }
          int len = height.length;
          // leftH[i]表示第i列左边最高高度，不包括第i列的高度
          // rightH[i]表示第i列右边最高高度，不包括第i列的高度
          // 根据木板效应，装水取决于最短木板，因此比较最短木板与当前水位看是否能够装水
          int[] left = new int[len];
          int[] right = new int[len];
          for (int i = 1; i < len; ++i) {
              left[i] = Math.max(height[i-1], left[i-1]);
          }
          for (int i = len-2; i >= 0; --i) {
              right[i] = Math.max(height[i+1], right[i+1]);
          }
          int ans = 0;
          for (int i = 1; i < len-1; ++i) {
              int tmp = Math.min(left[i], right[i]);
              if (tmp > height[i]) {
                  ans += tmp - height[i];
              }
          }
          return ans;
      }
  }
  
7.矩阵置零(leetcode 73)
  代码：
  class Solution {
      public void setZeroes(int[][] matrix) {
          if (matrix == null || matrix.length < 1 || matrix.length < 1) {
              return;
          }
          boolean row_0_flag = false;
          boolean col_0_flag = false;
          // 以第一行和第一列记录该行或者该列是否有0
          // 事先以bool值标记第一行和第一列是否有0
          int row = matrix.length;
          int col = matrix[0].length;
          for (int i = 0; i < col; ++i) {
              if (matrix[0][i] == 0) {
                  row_0_flag = true;
                  break;
              }
          }
          for (int j = 0; j < row; ++j) {
              if (matrix[j][0] == 0) {
                  col_0_flag = true;
                  break;
              }
          }
          for (int i = 1; i < row; ++i) {
              for (int j = 0; j < col; ++j) {
                  if (matrix[i][j] == 0) {
                      matrix[i][0] = 0;
                      break;
                  }
              }
          }
          for (int i = 1; i < col; ++i) {
              for (int j = 0; j < row; ++j) {
                  if (matrix[j][i] == 0) {
                      matrix[0][i] = 0;
                      break;
                  }
              }
          }
          for (int i = 1; i < row; ++i) {
              for (int j = 1; j < col; ++j) {
                  if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                      matrix[i][j] = 0;
                  }
              }
          }
          if (row_0_flag) {
              for (int i = 0; i < col; ++i) {
                  matrix[0][i] = 0;
              }
          }
          if (col_0_flag) {
              for (int i = 0; i < row; ++i) {
                  matrix[i][0] = 0;
              }
          }
      }
  }

8.旋转图像（leetcode 48）
  代码：
  class Solution {
      public void rotate(int[][] matrix) {
          // 上下对折，再y=-x对折
          // 如果是逆时针旋转90度，则是上下对折，再y=x对折
          if (matrix == null || matrix.length < 1 || matrix[0].length < 1) {
              return;
          }
          int n = matrix.length;
          int low = 0;
          int high = n-1;
          while (low < high) {
              for (int i = 0; i < n; ++i) {
                  int tmp = matrix[low][i];
                  matrix[low][i] = matrix[high][i];
                  matrix[high][i] = tmp;
              }
              ++low;
              --high;
          }
          for (int i = 0; i < n; ++i) {
              for (int j = 0; j < i; ++j) {
                  int tmp = matrix[i][j];
                  matrix[i][j] = matrix[j][i];
                  matrix[j][i] = tmp;
              }
          }
      }
  }
  
9.螺旋矩阵（leetcode 54）
  代码：
  class Solution {
      public List<Integer> spiralOrder(int[][] matrix) {
          List<Integer> ans = new ArrayList<>();
          if (matrix == null || matrix.length < 1 || matrix[0].length < 1) {
              return ans;
          }
          int m = matrix.length;
          int n = matrix[0].length;
          int left = 0;
          int right = n-1;
          int low = 0;
          int high = m-1;
          int cnt = 0;
          // 注意cnt的控制
          while (cnt < m*n) {
              for (int i = left; i <= right && cnt < m*n; ++i) {
                  ans.add(matrix[low][i]);
                  ++cnt;
              }
              ++low;
              for (int i = low; i <= high && cnt < m*n; ++i) {
                  ans.add(matrix[i][right]);
                  ++cnt;
              }
              --right;
              for (int i = right; i >= left && cnt < m*n; --i) {
                  ans.add(matrix[high][i]);
                  ++cnt;
              }
              --high;
              for (int i = high; i >= low && cnt < m*n; --i) {
                  ans.add(matrix[i][left]);
                  ++cnt;
              }
              ++left;

          }
          return ans;
      }
  }
  
10.两数相加 II(leetcode 445)
  代码：
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) { val = x; }
   * }
   */
  class Solution {

      public ListNode reverse(ListNode node) {
          ListNode ret = new ListNode(-1);
          while (node != null) {
              ListNode tmp = new ListNode(node.val);
              tmp.next = ret.next;
              ret.next = tmp;
              node = node.next;
          }
          return ret.next;
      }

      public ListNode add(ListNode l1, ListNode l2) {
          if (l1 == null || l2 == null) {
              if (l1 == null) {
                  return l2;
              } else {
                  return l1;
              }
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          int pre = 0;
          while (l1 != null && l2 != null) {
              int cur = l1.val + l2.val + pre;
              int val = cur % 10;
              pre = cur / 10;
              ListNode tmp = new ListNode(val);
              ans.next = tmp;
              ans = ans.next;
              l1 = l1.next;
              l2 = l2.next;
          }
          if (l1 != null) {
              while (l1 != null) {
                  if (pre == 0) {
                      ans.next = l1;
                      break;
                  }
                  int cur = l1.val + pre;
                  int val = cur % 10;
                  pre = cur / 10;
                  ListNode tmp = new ListNode(val);
                  ans.next = tmp;
                  ans = ans.next;
                  l1 = l1.next;
              }
          } else if (l2 != null) {
              while (l2 != null) {
                  if (pre == 0) {
                      ans.next = l2;
                      break;
                  }
                  int cur = l2.val + pre;
                  int val = cur % 10;
                  pre = cur / 10;
                  ListNode tmp = new ListNode(val);
                  ans.next = tmp;
                  ans = ans.next;
                  l2 = l2.next;
              }
          }
          if (pre != 0) {
              ListNode tmp = new ListNode(pre);
              ans.next = tmp;
          }
          return ret.next;
      }

      public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
          if (l1 == null || l2 == null) {
              if (l1 == null) {
                  return l2;
              } else {
                  return l1;
              }
          }
          l1 = reverse(l1);
          l2 = reverse(l2);
          ListNode ans = add(l1, l2);
          return reverse(ans);
      }
  }
  
11.复制带随机指针的链表(leetcode 138)
  代码：
  /*
  // Definition for a Node.
  class Node {
      int val;
      Node next;
      Node random;

      public Node(int val) {
          this.val = val;
          this.next = null;
          this.random = null;
      }
  }
  */

  class Solution {
      public Node copyRandomList(Node head) {
          if (head == null) {
              return head;
          }
          Node ans = head;
          while (ans != null) {
              Node tmp = new Node(ans.val);
              tmp.next = ans.next;
              ans.next = tmp;
              ans = tmp.next;
          }
          ans = head;
          while (ans != null) {
              if (ans.random != null) {
                  ans.next.random = ans.random.next;
              }
              ans = ans.next.next;
          }
          Node oldN = head;
          Node newN = head.next;
          ans = newN;
          while (oldN != null) {
              oldN.next = oldN.next.next;
              newN.next = newN.next == null ? null : newN.next.next;
              oldN = oldN.next;
              newN = newN.next;
          }
          return ans;
      }
  }
  
12.验证二叉搜索树(leetcode 89)
  代码：
  class Solution {
    
      TreeNode pre;

      public boolean isValidBST(TreeNode root) {
          if (root == null) {
              return true;
          }
          if (!isValidBST(root.left)) {
              return false;
          }
          if (pre != null && pre.val >= root.val) {
              return false;
          }
          pre = root;
          return isValidBST(root.right);
      }
  }
  
13. 填充每个节点的下一个右侧节点指针(leetcode 116)
  代码：
  class Solution {
      public Node connect(Node root) {
          if (root == null) {
              return root;
          }
          if (root.left != null) {
              root.left.next = root.right;
              if (root.next != null) {
                  root.right.next = root.next.left;
              }
          }
          connect(root.left);
          connect(root.right);
          return root;
      }
  }
变体：填充每个节点的下一个右侧节点指针 II（leetcode 117）
  代码：
  class Solution {
    
      public Node getNext(Node node) {
          if (node == null) {
              return node;
          }
          while (node.next != null) {
              if (node.next.left != null) {
                  return node.next.left;
              }
              if (node.next.right != null) {
                  return node.next.right;
              }
              node = node.next;
          }
          return null;
      }

      public Node connect(Node root) {
          if (root == null) {
              return root;
          }
          if (root.left != null && root.right != null) {
              root.left.next = root.right;
              root.right.next = getNext(root);
          } else if (root.left != null) {
              root.left.next = getNext(root);
          } else if (root.right != null){
              root.right.next = getNext(root);
          }
          connect(root.right);
          connect(root.left);
          return root;
      }
  }
  
14.岛屿数量(leetcode 200)
  代码：
  class Solution {
    
      //private char[][] array;
      private int[] dx = {-1, 0, 1, 0};
      private int[] dy = {0, 1, 0, -1};

      public void dfs (char[][] array, int x, int y) {
          if (x < 0 || x >= array.length || y < 0 || y >= array[0].length || array[x][y] == '0') {
              return;
          }
          array[x][y] = '0';
          for (int i = 0; i < dx.length; ++i) {
              dfs(array, x+dx[i], y+dy[i]);
          }
      }

      public int numIslands(char[][] grid) {
          if (grid == null || grid.length < 1 || grid[0].length < 1) {
              return 0;
          }
          char[][] array = grid;
          int ans = 0;
          for (int i = 0; i < array.length; ++i) {
              for (int j = 0; j < array[0].length; ++j) {
                  if (array[i][j] == '1') {
                      ++ans;
                      //array[i][j] = '0';
                      dfs(array, i, j);
                  }
              }
          }
          return ans;
      }
  }
  
15.克隆图（leetcode 133）
  代码：
  class Solution {
    
      HashMap<Node, Node> map;

      public Node dfs (Node node) {
          if (node == null) {
              return node;
          }
          Node dst = new Node(node.val);
          if (map.containsKey(node)) {
              return map.get(node);
          }
          map.put(node, dst);
          for (Node nei : node.neighbors) {
              map.get(node).neighbors.add(dfs(nei));
          }
          return map.get(node);
      }

      public Node cloneGraph(Node node) {
          if (node == null) {
              return null;
          }
          map = new HashMap<>();
          dfs(node);
          return map.get(node);
      }
  }
