1.参考
链接1：https://www.nowcoder.com/discuss/425581
链接2：https://github.com/lizeyang18/byteDanceAlgorithm

2.重点
2.1.股票买卖
2.2.排序数组，平方后，数组当中有多少不同的数字（相同算一个）
  参考：https://blog.csdn.net/qq_28468707/article/details/103672590?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
  代码：
  public class Main1 {

      public int cntNums (int[] nums) {
          int ans = 0;
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int len = nums.length;
          int l = 0;
          int r = len - 1;
          int preDel = Integer.MAX_VALUE;
          while (l <= r) {
              if (Math.abs(nums[l]) > Math.abs(nums[r])) {
                  if (preDel != Math.abs(nums[l])) {
                      ++ans;
                      preDel = Math.abs(nums[l]);
                  }
                  ++l;
              } else {
                  if (preDel != Math.abs(nums[r])) {
                      ++ans;
                      preDel = Math.abs(nums[r]);
                  }
                  --r;
              }
          }
          return ans;
      }

      public static void main(String[] args) {
          int[] nums = {-5,-3,-1,1,1,2,5};
          Main1 main1 = new Main1();
          int ret = main1.cntNums(nums);
          System.out.println(ret);
      }
  }
变体，先增后减数组的不重复数字个数
  代码：
  public class Main2 {

      public int cntNums (int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int ans = 0;
          int l = 0;
          int r = nums.length-1;
          int preDel = Integer.MAX_VALUE;
          while (l <= r) {
              if (nums[l] < nums[r]) {
                  if (preDel != nums[l]) {
                      ++ans;
                      preDel = nums[l];
                  }
                  ++l;
              } else {
                  if (preDel != nums[r]) {
                      ++ans;
                      preDel = nums[r];
                  }
                  --r;
              }
          }
          return ans;
      }

      public static void main(String[] args) {
          Main2 main2 = new Main2();
          int[] nums= {1, 3, 9, 1};
          int ret = main2.cntNums(nums);
          System.out.println(ret);
      }
  }
  
2.3.写一个函数，求平方根，函数参数为目标数字和精度
  代码：
  public class Main2 {

      public double cntNums (double target, double g) {
          double l = 0;
          double r = target;
          while (r-l > g) {
              double mid = (l+r)/2;
              if (mid * mid < target) {
                  l = mid;
              } else {
                  r = mid;
              }
          }
          return (l+r)/2;
      }

      public static void main(String[] args) {
          Main2 main2 = new Main2();
          int[] nums= {1, 3, 9, 1};
          double ret = main2.cntNums(0.045, 0.001);
          System.out.println(ret);
      }
  }

2.4.链表求和(leetcode 2. Add Two Numbers)
  代码：
  class Solution {
      public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
          if (l1 == null || l2 == null) {
              if (l1 == null && l2 == null) {
                  return null;
              } else if (l1 == null) {
                  return l2;
              } else {
                  return l1;
              }
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          int add = 0;
          while (l1 != null && l2 != null) {
              int cur = (l1.val + l2.val + add) % 10;
              add = (l1.val + l2.val + add) / 10;
              ListNode tmp = new ListNode(cur);
              ans.next = tmp;
              ans = ans.next;
              l1 = l1.next;
              l2 = l2.next;
          }
          if (l1 != null || l2 != null) {
              while (l1 != null) {
                  if (add == 0) {
                      ans.next = l1;
                      break;
                  }
                  int cur = (l1.val + add) % 10;
                  add = (l1.val + add) / 10;
                  ListNode tmp = new ListNode(cur);
                  ans.next = tmp;
                  ans = ans.next;
                  l1 = l1.next;
              }
              while (l2 != null) {
                  if (add == 0) {
                      ans.next = l2;
                      break;
                  }
                  int cur = (l2.val + add) % 10;
                  add = (l2.val + add) / 10;
                  ListNode tmp = new ListNode(cur);
                  ans.next = tmp;
                  ans = ans.next;
                  l2 = l2.next;
              }
          }
          if (add > 0) {
              ListNode tmp = new ListNode(add);
              ans.next = tmp;
          }
          return ret.next;
      }
  }
  
2.5.未排序整数数组的最长连续序列长度（leetcode 128. Longest Consecutive Sequence）
  代码：
  class Solution {
      public int longestConsecutive(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int ans = 0;
          HashSet<Integer> set = new HashSet<>();
          for (int num : nums) {
              set.add(num);
          }
          for (int num : nums) {
              if (!set.contains(num-1)) {
                  int curAns = 1;
                  while (set.contains(num+1)) {
                      ++curAns;
                      ++num;
                  }
                  ans = Math.max(ans, curAns);
              }
          }
          return ans;
      }
  }
  
2.6.接雨水（leetcode 42. Trapping Rain Water）
  代码：
  class Solution {
      public int trap(int[] height) {
          if (height == null || height.length < 1) {
              return 0;
          }
          int len = height.length;
          // leftH[i]表示第i列左边最高高度，不包括第i列的高度
          // rightH[i]表示第i列右边最高高度，不包括第i列的高度
          // 根据木板效应，装水取决于最短木板，因此比较最短木板与当前水位看是否能够装水
          int[] leftH = new int[len];
          int[] rightH = new int[len];
          for (int i = 1; i < len; ++i) {
              leftH[i] = Math.max(leftH[i-1], height[i-1]);
          }
          for (int j = len-2; j >= 0; --j) {
              rightH[j] = Math.max(rightH[j+1], height[j+1]);
          }
          int ans = 0;
          for (int i = 1; i < len; ++i) {
              int minH = Math.min(leftH[i], rightH[i]);
              if (minH > height[i]) {
                  ans += minH - height[i];
              }
          }
          return ans;
      }
  }
  
2.7.链表翻转
2.7.1.从m到n翻转（leetcode 92. Reverse Linked List II）
  代码：
  class Solution {
      public ListNode reverseBetween(ListNode head, int m, int n) {
          if (head == null || head.next == null) {
              return head;
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          int cnt = 1;
          while (head != null) {
              if (cnt == m) {
                  ListNode tmp1 = new ListNode(-1);
                  // ListNode tmp2 = new ListNode(-1);
                  while (cnt <= n && head != null) {
                      ListNode cur = new ListNode(head.val);
                      cur.next = tmp1.next;
                      tmp1.next = cur;
                      ++cnt;
                      head = head.next;
                  }
                  ans.next = tmp1.next;
                  while (ans.next != null) {
                      ans = ans.next;
                  }
              } else {
                  ans.next = new ListNode(head.val);
                  ans = ans.next;
                  head = head.next;
                  ++cnt;
              }
          }
          return ret.next;
      }
  }
2.7.2.全部翻转（leetcode 206. Reverse Linked List）
  代码：
  class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode ans = new ListNode(-1);
        // ListNode ret = ans;
        while (head != null) {
            ListNode tmp = new ListNode(head.val);
            tmp.next = ans.next;
            ans.next = tmp;
            head = head.next;
        }
        return ans.next;
    }
}
2.7.3.隔k个翻转(leetcode 25. Reverse Nodes in k-Group)
  代码：
  class Solution {
      public ListNode reverseKGroup(ListNode head, int k) {
          if (head == null || head.next == null) {
              return head;
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          while (head != null) {
              int cnt = k;
              ListNode node1 = head;
              // ListNode node1 = head;
              while (cnt > 0 && head != null) {
                  head = head.next;
                  --cnt;
              }
              if (cnt > 0) {
                  ans.next = node1;
                  break;
              } else {
                  head = node1;
                  cnt = k;
                  ListNode t1 = new ListNode(-1);
                  ListNode t2 = t1;
                  while (cnt > 0) {
                      ListNode tmp = new ListNode(head.val);
                      tmp.next = t1.next;
                      t1.next = tmp;
                      head = head.next;
                      --cnt;
                  }
                  ans.next = t2.next;
                  while (ans.next != null) {
                      ans = ans.next;
                  }
              }
          }
          return ret.next;
      }
  }
  
2.8.反转字符串里的单词（leetcode 151. Reverse Words in a String）
  代码：
  class Solution {
    
      private String str;

      public String reverse (int start) {
          if (start >= str.length()) {
              return "";
          }
          StringBuilder cur = new StringBuilder("");
          int i = start;
          for (; i < str.length(); ++i) {
              if (str.charAt(i) != ' ') {
                  cur.append(str.charAt(i));
              } else {
                  break;
              }
          }
          for (; i < str.length(); ++i) {
              if (str.charAt(i) != ' ') {
                  break;
              }
          }
          String next = reverse(i);
          return next.length() == 0 ? cur.toString() : next + " " + cur.toString();
      }

      public String reverseWords(String s) {
          if (s == null || s.length() < 1) {
              return s;
          }
          str = s;
          int i = 0;
          for (; i < str.length(); ++i) {
              if (str.charAt(i) != ' ') {
                  break;
              }
          }
          return reverse(i);
      }
  }
  
2.9.和为s的连续正数序列（剑指offer57-2，滑动窗口）
  代码：
  class Solution {
      public int[][] findContinuousSequence(int target) {
          int start = 1;
          int end = 2;
          int sum = 1;
          List<int[]> ans = new ArrayList<>();
          while (start <= (target/2 + 1)) {
              if (sum == target) {
                  int[] tmp = new int[end - start];
                  int cnt = 0;
                  for (int i = start; i < end; ++i) {
                      tmp[cnt++] = i;
                  }
                  ans.add(tmp);
                  sum -= start;
                  ++start;
              } else if (sum < target) {
                  sum += end;
                  ++end;
              } else {
                  sum -= start;
                  ++start;
              }
          }
          return ans.toArray(new int[ans.size()][]);
      }
  }
  
2.10.递增的三元子序列（leetcode 334. Increasing Triplet Subsequence）
  代码：
  class Solution {
      public boolean increasingTriplet(int[] nums) {
          if (nums == null || nums.length < 3) {
              return false;
          }
          // 保存两个最小值，看是否有第三个数大于这两个值
          int firstMin = Integer.MAX_VALUE;
          int secondMin = Integer.MAX_VALUE;
          for (int num : nums) {
              if (num <= firstMin) {
                  firstMin = num;
              } else if (num <= secondMin) {
                  secondMin = num;
              } else {
                  return true;
              }
          }
          return false;
      }
  }

2.11.下一个排列（leetcode 31. Next Permutation）
  代码：
  class Solution {
    
      public void reverse(int[] arrays, int start, int end) {
          while (start < end) {
              int tmp = arrays[start];
              arrays[start] = arrays[end];
              arrays[end] = tmp;
              ++start;
              --end;
          }
      }


      public void nextPermutation(int[] nums) {
          if (nums == null || nums.length < 1) {
              return;
          }
          int i = nums.length - 2;
          // 从数组最后面开始找第一个降序的位置(nums[i] < nums[i+1])
          while (i >= 0) {
              if (nums[i] < nums[i+1]) {
                  break;
              }
              --i;
          }
          // 整个数组降序，重排
          if (i < 0) {
              reverse(nums, 0, nums.length-1);
              return;
          }
          // 从后面找比nums[i]大的第一个数nums[j], i < j,交换nums[i]、nums[j]两个数，从i+1的位置开始重排
          int j = nums.length - 1;
          while (j > i) {
              if (nums[j] > nums[i]) {
                  break;
              }
              --j;
          }
          int tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
          reverse(nums, i+1, nums.length-1);
      }
  }

2.12.缺失的数字
2.12.1.简单版（leetcode 268. Missing Number）
  代码：
  class Solution {
      public int missingNumber(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          /*
          // 高斯公式
          int n = nums.length;
          int target = n*(n+1)/2;
          for (int num : nums) {
              target -= num;
          }
          return target;
          */
          int n = nums.length;
          for (int i = 0; i < nums.length; ++i) {
              n ^= i ^ nums[i];
          }
          return n;
      }
  }
2.12.2.缺失的第一个正数（leetcode 41. First Missing Positive）
  代码：
  class Solution {
      public int firstMissingPositive(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 1;
          }
          HashSet<Integer> set = new HashSet<>();
          for (int num : nums) {
              set.add(num);
          }
          int n = nums.length;
          for (int i = 1; i <= n; ++i) {
              if (!set.contains(i)) {
                  return i;
              }
          }
          return n+1;
      }
  }
  
2.13.在升序数组中发现数字出现的第一个位置和最后一个位置（leetcode 34. Find First and Last Position of Element in Sorted Array）
  代码：
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          if (nums == null || nums.length < 1) {
              return new int[]{-1, -1};
          }
          int[] ans = new int[2];
          int l = 0;
          int r = nums.length - 1;
          while (l < r) {
              int mid = l + (r-l)/2;
              if (nums[mid] >= target) {
                  r = mid;
              } else {
                  l = mid + 1;
              }
          }
          int a = nums[l] == target ? l : -1;
          l = 0;
          r = nums.length - 1;
          while (l < r) {
              int mid = l + (r-l+1)/2;
              if (nums[mid] <= target) {
                  l = mid;
              } else {
                  r = mid - 1;
              }
          }
          int b = nums[l] == target ? l : -1;
          ans[0] = a;
          ans[1] = b;
          return ans;
      }
  }
  
2.14.数组里的三个数的和是否是0（leetcode 15. 3Sum）
  思路：数组排序；固定一头，剩下两个双指针；去重；
  代码：
  class Solution {
    
      public List<List<Integer>> threeSum(int[] nums) {
          List<List<Integer>> ans = new ArrayList<>();
          if (nums == null || nums.length < 3) {
              return ans;
          }
          Arrays.sort(nums);
          for (int i = 0; i <= nums.length - 3; ++i) {
              if (nums[i] > 0) {
                  break;
              }
              if (i > 0 && nums[i] == nums[i-1]) {
                  continue;
              }
              int sum = nums[i];
              int j = i+1;
              int k = nums.length - 1;
              while (j < k) {
                  int tmp = nums[j] + nums[k];
                  if (tmp + sum == 0) {
                      List<Integer> t = new ArrayList<>();
                      t.add(nums[i]);
                      t.add(nums[j]);
                      t.add(nums[k]);
                      ans.add(t);
                      while (j < k && nums[j] == nums[++j]) {
                          // ++j;
                      }
                      while (j < k && nums[k] == nums[--k]) {
                          // --k;
                      }
                  } else if (tmp + sum < 0) {
                      while (j < k && nums[j] == nums[++j]) {
                          // ++j;
                      }
                  } else {
                      while (j < k && nums[k] == nums[--k]) {
                          // --k;
                      }
                  }
              }
          }
          return ans;
      }
  }
  
2.15.多线程循环打印ABC
  参考：https://paine1690.github.io/post/72391014.html
  代码：
  import java.util.*;
  import java.util.concurrent.Executor;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;

  public class Main3 implements Runnable {

      // 需要不同线程标识
      private static int cnt = 0;
      // 需要锁
      private static Object lock = new Object();
      private int name;

      public Main3 (int v) {
          name = v;
      }

      public void run(){
          try {
              while (true) {
                  synchronized (lock) {
                      while (cnt%3 != name) {
                          lock.wait();
                      }
                      System.out.println((char)('A' + cnt%3));
                      ++cnt;
                      lock.notifyAll();
                  }
              }
          } catch(Exception ex) {
              ex.printStackTrace();
          }

      }
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newFixedThreadPool(3);
          executorService.execute(new Main3(0));
          executorService.execute(new Main3(1));
          executorService.execute(new Main3(2));
      }
  }
  
2.16.以log(m)+log(n)的时间复杂度完成矩阵搜索(leetcode 74. Search a 2D Matrix)
  代码：
  class Solution {
      public boolean searchMatrix(int[][] matrix, int target) {
          if (matrix == null || matrix.length < 1 || matrix[0].length < 1) {
              return false;
          }
          int m = matrix.length;
          int n = matrix[0].length;
          int l = 0;
          int r = m-1;
          while (l < r) {
              int mid = l + (r-l+1)/2;
              if (matrix[mid][0] > target) {
                  r = mid - 1;
              } else {
                  l = mid;
              }
          }
          int row = l;
          l = 0;
          r = n-1;
          while (l < r) {
              int mid = l + (r-l+1)/2;
              if (matrix[row][mid] > target) {
                  r = mid - 1;
              } else {
                  l = mid;
              }
          }
          return matrix[row][l] == target;
      }
  }
  
2.17.剑指 Offer 48. 最长不含重复字符的子字符串
  代码：
  class Solution {
      public int lengthOfLongestSubstring(String s) {
          if (s == null || s.length() < 1) {
              return 0;
          }
          HashMap<Character, Integer> map = new HashMap<>();
          int ans = 0;
          // dp[i]表示以第i个字符接受的不重复字符串长度
          // 判断当前字符是否出现过，未出现过，dp[i] = dp[i-1] + 1
          // 出现过，比较上次出现的位置lastIndex是否在dp[i-1]的范围内，即(i-1)-lastIndex + 1与dp[i-1]的比较
          int len = s.length();
          int[] dp = new int[len];
          for (int i = 0; i < s.length(); ++i) {
              char cur = s.charAt(i);
              if (map.containsKey(cur)) {
                  int lastIndex = map.get(cur);
                  if (dp[i-1] < i - lastIndex) {
                      dp[i] = dp[i-1] + 1;
                  } else {
                      dp[i] = i - lastIndex;
                  }
              } else {
                  if (i == 0) {
                      dp[i] = 1;
                  } else {
                      dp[i] = dp[i-1] + 1;
                  }
              }
              map.put(cur, i);
              ans = Math.max(ans, dp[i]);
          }
          return ans;
      }
  }
  
2.18.搜索旋转排序数组的目标数字位置(leetcode 33. Search in Rotated Sorted Array)
  思路：找到旋转位置然后二分
  代码：
  class Solution {
      public int search(int[] nums, int target) {
          if (nums == null || nums.length < 1) {
              return -1;
          }
          int l = 0;
          int r = nums.length - 1;
          int index = -1;
          while (l < r) {
              int mid = l + (r-l)/2;
              if (nums[mid] > nums[r]) {
                  l = mid + 1;
              } else {
                  r = mid;
              }
          }
          index = l;
          if (nums[index] == target) {
              return index;
          } else if (nums[0] > target || index == 0) {
              l = index;
              r = nums.length - 1;
              while (l < r) {
                  int mid = l + (r-l)/2;
                  if (nums[mid] >= target) {
                      r = mid;
                  } else {
                      l = mid + 1;
                  }
              }
              return nums[l] == target ? l : -1;
          } else {
              l = 0;
              r = index - 1;
              while (l < r) {
                  int mid = l + (r-l)/2;
                  if (nums[mid] >= target) {
                      r = mid;
                  } else {
                      l = mid + 1;
                  }
              }
              return nums[l] == target ? l : -1;
          }

      }
  }
相关一个有序数组，从随即一位截断，把前段放在后边，寻找中位数
  代码：
  public class Main4 {

      private static int[] nums;

      private static int find(){
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int len = nums.length;
          int index = len - 1;
          int cnt = 0;
          while (index > 0) {
              if (nums[index-1] > nums[index]) {
                  break;
              }
              --index;
              ++cnt;
          }
          int mid = len/2;
          if (cnt + 1 <= len/2) {
              return nums[mid - cnt - 1];
          } else {
              return nums[index + mid];
          }
      }

      public static void main(String[] args) {
          int[] arrays = {4, 5, 6, 7, -2, -1, 1, 2, 3};
          nums = arrays;
          System.out.println(find());
      }
  }
  
2.19.一辆公交车，有m站，最多坐n人，输入一路上票的信息（即上车下车站），输出会不会超载
  代码：
  import java.util.*;

  public class Main5 {

      private static int[][] nums;
      private static int n;

      private static boolean judge () {
          Arrays.sort(
              nums,
              (a, b) -> {
                  if (a[0] == b[0]) {
                      return a[1] - b[1];
                  } else {
                      return a[0] - b[0];
                  }
              }
          );
          HashMap<Integer, Integer> map = new HashMap<>();
          for (int[] num : nums) {
              for (int i = num[0]; i <= num[1]; ++i) {
                  if (map.containsKey(i)) {
                      if (map.get(i) + 1 > n) {
                          return false;
                      } else {
                          map.put(i, map.get(i)+1);
                      }
                  } else {
                      map.put(i, 1);
                  }
              }
          }
          return true;
      }

      public static void main(String[] args) {
          int[][] arrays = {{1,5},{2,3},{2,4},{2,5},{4,5},{3,4},{1,2}};
          nums = arrays;
          n = 5;
          if (judge()) {
              System.out.println("True.");
          } else {
              System.out.println("False.");
          }

      }
  }
  
2.20.求完全二叉树的节点数（leetcode 222. Count Complete Tree Nodes）
  代码：
  class Solution {
    
      public int height (TreeNode node) {
          // 完全二叉树求树高一直求左节点即可
          if (node == null) {
              return 0;
          }
          return 1 + height(node.left);
      }

      public int countNodes(TreeNode root) {
          if (root == null) {
              return 0;
          }
          // 复杂度O(log(n)^2)，因为查找节点取一半即可，求节点的高度也是log(n)
          int rootH = height(root);
          int rightH = height(root.right);
          if (rootH == rightH + 1) {
              // 左右子树高度相同，说明左子树是满二叉树，总节点数等于左子树节点+右子树节点+根节点1，左子树节点可由公式得到
              return (1 << rightH) - 1 + countNodes(root.right) + 1;
          } else {
              // 左右子树高度相同，说明右子树是满二叉树，总节点数等于左子树节点+右子树节点+根节点1，右子树节点可由公式得到
              return (1 << rightH) - 1 + countNodes(root.left) + 1;
          }
      }
  }
  
2.21.用链表实现栈
  代码：
  class MyStack {

      private LinkedList<Integer> queue;
      private int len;

      /** Initialize your data structure here. */
      public MyStack() {
          queue = new LinkedList<>();
          len = 0;
      }

      /** Push element x onto stack. */
      public void push(int x) {
          queue.add(x);
          ++len;
      }

      /** Removes the element on top of the stack and returns that element. */
      public int pop() {
          if (empty()) {
              return -1;
          }
          int ans = queue.remove(len-1);
          --len;
          return ans;
      }

      /** Get the top element. */
      public int top() {
          if (empty()) {
              return -1;
          }
          int ans = queue.get(len-1);
          return ans;
      }

      /** Returns whether the stack is empty. */
      public boolean empty() {
          return len == 0;
      }
  }
相关，队列实现栈（leetcode 225. Implement Stack using Queues）
  思路：
  // 保持inQueue为空，元素都在outQueue
  // 每次inQueue入队列，然后inQueue屁股后面加所有的outQueue
  // 再把所有的inQueue输入到outQueue，类似于头插法
  代码：
  class MyStack {

      private Queue<Integer> queue1;
      private Queue<Integer> queue2;

      /** Initialize your data structure here. */
      public MyStack() {
          queue1 = new LinkedList<>();
          queue2 = new LinkedList<>();
      }

      /** Push element x onto stack. */
      public void push(int x) {
          queue1.offer(x);
          while (!queue2.isEmpty()) {
              queue1.offer(queue2.poll());
          }
          while (!queue1.isEmpty()) {
              queue2.offer(queue1.poll());
          }
      }

      /** Removes the element on top of the stack and returns that element. */
      public int pop() {
          return queue2.poll();
      }

      /** Get the top element. */
      public int top() {
          return queue2.peek();
      }

      /** Returns whether the stack is empty. */
      public boolean empty() {
          return queue2.isEmpty();
      }
  }
  
2.22.约瑟夫环（剑指 Offer 62. 圆圈中最后剩下的数字）
  代码：
  class Solution {

      private int m;

      public int circle (int n) {
          if (n == 1) {
              return 1;
          }
          return (circle(n-1) + m - 1)% n + 1;
          // return (circle(n-1) + m )% n;
      }

      public int lastRemaining(int n, int m) {
          this.m = m;
          return circle(n)-1;
      }
  }
  
2.23.LRU（leetcode 146. LRU Cache）
  代码：
  class LRUCache {

      class Node {
          int key;
          int val;
          Node prev;
          Node next;
          public Node (int a, int b) {
              key = a;
              val = b;
          }
      }

      class DoubleList {  
          private Node head, tail; // 头尾虚节点
          private int size; // 链表元素数

          public DoubleList() {
              head = new Node(0, 0);
              tail = new Node(0, 0);
              head.next = tail;
              tail.prev = head;
              size = 0;
          }

          // 在链表头部添加节点 x
          public void addFirst(Node x) {
              x.next = head.next;
              x.prev = head;
              head.next.prev = x;
              head.next = x;
              size++;
          }

          // 删除链表中的 x 节点（x 一定存在）
          public void remove(Node x) {
              x.prev.next = x.next;
              x.next.prev = x.prev;
              size--;
          }

          // 删除链表中最后一个节点，并返回该节点
          public Node removeLast() {
              if (tail.prev == head)
                  return null;
              Node last = tail.prev;
              remove(last);
              return last;
          }

          // 返回链表长度
          public int size() { return size; }
      }

      private HashMap<Integer, Node> map;
      private DoubleList list;
      private int len;
      // 哈希表用于值的取
      // 双向链表用于增删，使用双向是为了保证增删O(1)

      public LRUCache(int capacity) {
          map = new HashMap<>();
          list = new DoubleList();
          len = capacity;
      }

      public int get(int key) {
          if (!map.containsKey(key)) {
              return -1;
          }
          int val = map.get(key).val;
          put(key, val);
          return val;
      }

      public void put(int key, int value) {
          Node cur = new Node(key, value);
          if (map.containsKey(key)) {
              Node node = map.get(key);
              list.remove(node);
              list.addFirst(cur);
              map.put(key, cur);
          } else {
              if (len == list.size()) {
                  Node last = list.removeLast();
                  map.remove(last.key);
                  list.addFirst(cur);

              } else {
                  list.addFirst(cur);
              }
              map.put(key, cur);
          }

      }
  }
  
2.24.二叉树右视图(leetcode )
  思路：O(log n)解法，递归剪枝
  代码：199. Binary Tree Right Side View
  class Solution {
    
      List<Integer> ans;
      int totalHeight;
      int curHeight;

      public int getH(TreeNode node) {
          if (node == null) {
              return 0;
          }
          if (node.left == null && node.right == null) {
              return 1;
          }
          return Math.max(getH(node.left), getH(node.right)) + 1;
      }

      public void dfs (TreeNode node, int h) {
          if (node == null) {
              return;
          }
          if (curHeight >= totalHeight) {
              return;
          }
          if (h == curHeight) {
              ans.add(node.val);
              ++curHeight;
          }
          dfs(node.right, h+1);
          dfs(node.left, h+1);
      }

      public List<Integer> rightSideView(TreeNode root) {
          ans = new ArrayList<>();
          if (root == null) {
              return ans;
          }
          totalHeight = getH(root);
          curHeight = 0;
          dfs(root, 0);
          return ans;
      }
  }
  
leetcode bytedance 专题：
1.字符串的排列（leetcode 567）
  思路：滑动窗口+字符数组记录个数，含排列等价于窗口内字符的种类和个数相等
  代码：
  class Solution {
    
      public boolean judge(int[] nums1, int[] nums2) {
          for (int i = 0; i < nums1.length; ++i) {
              if (nums1[i] != nums2[i]) {
                  return false;
              }
          }
          return true;
      }

      public boolean checkInclusion(String s1, String s2) {
          if (s1 == null || s2 == null || s1.length() > s2.length()) {
              return false;
          }
          int[] cnt1 = new int[26];
          int[] cnt2 = new int[26];
          int i = 0;
          for (; i < s1.length(); ++i) {
              ++cnt1[s1.charAt(i) - 'a'];
              ++cnt2[s2.charAt(i) - 'a'];
          }
          if (judge(cnt1, cnt2)) {
              return true;
          }
          while (i < s2.length()) {
              --cnt2[s2.charAt(i-s1.length()) - 'a'];
              ++cnt2[s2.charAt(i) - 'a'];
              if (judge(cnt1, cnt2)) {
                  return true;
              }
              ++i;
          }
          return false;
      }
  }
  
2.字符串相乘(leetcode 43)
  代码：
  class Solution {
      public String multiply(String num1, String num2) {
          if (num1 == null || num2 == null || num1.length() < 1 || num2.length() < 1) {
              return "";
          }
          int m = num1.length();
          int n = num2.length();
          int[] ret = new int[m+n];
          // 反转
          num1 = new StringBuilder(new String(num1)).reverse().toString();
          num2 = new StringBuilder(new String(num2)).reverse().toString();
          // 按位乘
          for (int i = 0; i < num1.length(); ++i) {
              for (int j = 0; j < num2.length(); ++j) {
                  ret[i+j] += (int)(num1.charAt(i) - '0') * (int)(num2.charAt(j) - '0');
              }
          }
          for (int i = 0; i < ret.length-1; ++i) {
              if (ret[i] > 9) {
                  int tmp = ret[i];
                  ret[i] = tmp % 10;
                  ret[i+1] += tmp / 10;
              }
          }

          StringBuilder sb = new StringBuilder("");
          for (int i = ret.length-1; i >= 0; --i) {
              sb.append(ret[i]);
          }
          String ans = sb.toString();
          int i = 0;
          for (; i < ans.length(); ++i) {
              if (ans.charAt(i) != '0') {
                  break;
              }
          }
          return i == ans.length() ? "0" : ans.substring(i, ans.length());
      }
  }
  
3.简化路径(leetcode 71)
  代码：
  class Solution {
      public String simplifyPath(String path) {
          /*
          1.此题主要考察的是栈,所以定义一个辅助栈;
          2.先把字符串以"/"为分隔符分割成数组,此时数组有"路径"、""、"."、".."这四种情况;
          3.遍历数组,当s[i].equals("..")并且栈不空时pop,当!s[i].equals("") && !s[i].equals(".") && !s[i].equals(".."),即s[i]是路径入栈;
          4.栈空,返回"/",栈非空,用StringBuffer做一个连接返回即可;
          5完结。
          */
          if (path == null || path.length() < 1) {
              return "";
          }
          String[] strs = path.split("/");
          Stack<String> stack = new Stack<>();
          for (String str : strs) {
              if (str.equals("..")) {
                  if (!stack.isEmpty()) {
                      stack.pop();
                  }
              } else {
                  if (!str.equals("") && !str.equals(".")) {
                      stack.push(str);
                  }
              }
          }
          if (stack.isEmpty()) {
              return "/";
          }
          StringBuilder sb = new StringBuilder("");
          for (String str : stack) {
              sb.append("/").append(str);
          }
          return sb.toString();
      }
  }
  
4.复原IP地址（leetcode 93）
  代码：
  class Solution {
    
      private List<String> ans;
      private String str;

      public void dfs (int index, ArrayList<String> list) {
          if (list.size() >= 4) {
              if (index >= str.length()) {
                  ans.add(String.join(".", list));
              }
              return;
          }
          for (int i = index + 1; i <= index + 3 && i <= str.length(); ++i) {
              String cur = str.substring(index, i);
              if ((cur.startsWith("0") && cur.length() > 1) || (Integer.parseInt(cur) > 255)) {
                  continue;
              }
              list.add(cur);
              dfs(i, list);
              list.remove(list.size()-1);
          }
      }

      public List<String> restoreIpAddresses(String s) {
          ans = new ArrayList<>();
          if (s == null || s.length() < 4 || s.length() > 12) {
              return ans;
          }
          str = s;
          dfs(0, new ArrayList<String>());
          return ans;
      }
  }

