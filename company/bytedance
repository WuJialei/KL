1.参考
链接1：https://www.nowcoder.com/discuss/425581
链接2：https://github.com/lizeyang18/byteDanceAlgorithm

2.重点
2.1.股票买卖
2.2.排序数组，平方后，数组当中有多少不同的数字（相同算一个）
  参考：https://blog.csdn.net/qq_28468707/article/details/103672590?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
  代码：
  public class Main1 {

      public int cntNums (int[] nums) {
          int ans = 0;
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int len = nums.length;
          int l = 0;
          int r = len - 1;
          int preDel = Integer.MAX_VALUE;
          while (l <= r) {
              if (Math.abs(nums[l]) > Math.abs(nums[r])) {
                  if (preDel != Math.abs(nums[l])) {
                      ++ans;
                      preDel = Math.abs(nums[l]);
                  }
                  ++l;
              } else {
                  if (preDel != Math.abs(nums[r])) {
                      ++ans;
                      preDel = Math.abs(nums[r]);
                  }
                  --r;
              }
          }
          return ans;
      }

      public static void main(String[] args) {
          int[] nums = {-5,-3,-1,1,1,2,5};
          Main1 main1 = new Main1();
          int ret = main1.cntNums(nums);
          System.out.println(ret);
      }
  }
变体，先增后减数组的不重复数字个数
  代码：
  public class Main2 {

      public int cntNums (int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int ans = 0;
          int l = 0;
          int r = nums.length-1;
          int preDel = Integer.MAX_VALUE;
          while (l <= r) {
              if (nums[l] < nums[r]) {
                  if (preDel != nums[l]) {
                      ++ans;
                      preDel = nums[l];
                  }
                  ++l;
              } else {
                  if (preDel != nums[r]) {
                      ++ans;
                      preDel = nums[r];
                  }
                  --r;
              }
          }
          return ans;
      }

      public static void main(String[] args) {
          Main2 main2 = new Main2();
          int[] nums= {1, 3, 9, 1};
          int ret = main2.cntNums(nums);
          System.out.println(ret);
      }
  }
  
2.3.写一个函数，求平方根，函数参数为目标数字和精度
  代码：
  public class Main2 {

      public double cntNums (double target, double g) {
          double l = 0;
          double r = target;
          while (r-l > g) {
              double mid = (l+r)/2;
              if (mid * mid < target) {
                  l = mid;
              } else {
                  r = mid;
              }
          }
          return (l+r)/2;
      }

      public static void main(String[] args) {
          Main2 main2 = new Main2();
          int[] nums= {1, 3, 9, 1};
          double ret = main2.cntNums(0.045, 0.001);
          System.out.println(ret);
      }
  }

2.4.链表求和(leetcode 2. Add Two Numbers)
  代码：
  class Solution {
      public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
          if (l1 == null || l2 == null) {
              if (l1 == null && l2 == null) {
                  return null;
              } else if (l1 == null) {
                  return l2;
              } else {
                  return l1;
              }
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          int add = 0;
          while (l1 != null && l2 != null) {
              int cur = (l1.val + l2.val + add) % 10;
              add = (l1.val + l2.val + add) / 10;
              ListNode tmp = new ListNode(cur);
              ans.next = tmp;
              ans = ans.next;
              l1 = l1.next;
              l2 = l2.next;
          }
          if (l1 != null || l2 != null) {
              while (l1 != null) {
                  if (add == 0) {
                      ans.next = l1;
                      break;
                  }
                  int cur = (l1.val + add) % 10;
                  add = (l1.val + add) / 10;
                  ListNode tmp = new ListNode(cur);
                  ans.next = tmp;
                  ans = ans.next;
                  l1 = l1.next;
              }
              while (l2 != null) {
                  if (add == 0) {
                      ans.next = l2;
                      break;
                  }
                  int cur = (l2.val + add) % 10;
                  add = (l2.val + add) / 10;
                  ListNode tmp = new ListNode(cur);
                  ans.next = tmp;
                  ans = ans.next;
                  l2 = l2.next;
              }
          }
          if (add > 0) {
              ListNode tmp = new ListNode(add);
              ans.next = tmp;
          }
          return ret.next;
      }
  }
  
2.5.未排序整数数组的最长连续序列长度（leetcode 128. Longest Consecutive Sequence）
  代码：
  class Solution {
      public int longestConsecutive(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int ans = 0;
          HashSet<Integer> set = new HashSet<>();
          for (int num : nums) {
              set.add(num);
          }
          for (int num : nums) {
              if (!set.contains(num-1)) {
                  int curAns = 1;
                  while (set.contains(num+1)) {
                      ++curAns;
                      ++num;
                  }
                  ans = Math.max(ans, curAns);
              }
          }
          return ans;
      }
  }
  
2.6.接雨水（leetcode 42. Trapping Rain Water）
  代码：
  class Solution {
      public int trap(int[] height) {
          if (height == null || height.length < 1) {
              return 0;
          }
          int len = height.length;
          // leftH[i]表示第i列左边最高高度，不包括第i列的高度
          // rightH[i]表示第i列右边最高高度，不包括第i列的高度
          // 根据木板效应，装水取决于最短木板，因此比较最短木板与当前水位看是否能够装水
          int[] leftH = new int[len];
          int[] rightH = new int[len];
          for (int i = 1; i < len; ++i) {
              leftH[i] = Math.max(leftH[i-1], height[i-1]);
          }
          for (int j = len-2; j >= 0; --j) {
              rightH[j] = Math.max(rightH[j+1], height[j+1]);
          }
          int ans = 0;
          for (int i = 1; i < len; ++i) {
              int minH = Math.min(leftH[i], rightH[i]);
              if (minH > height[i]) {
                  ans += minH - height[i];
              }
          }
          return ans;
      }
  }
  
2.7.链表翻转
2.7.1.从m到n翻转（leetcode 92. Reverse Linked List II）
  代码：
  class Solution {
      public ListNode reverseBetween(ListNode head, int m, int n) {
          if (head == null || head.next == null) {
              return head;
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          int cnt = 1;
          while (head != null) {
              if (cnt == m) {
                  ListNode tmp1 = new ListNode(-1);
                  // ListNode tmp2 = new ListNode(-1);
                  while (cnt <= n && head != null) {
                      ListNode cur = new ListNode(head.val);
                      cur.next = tmp1.next;
                      tmp1.next = cur;
                      ++cnt;
                      head = head.next;
                  }
                  ans.next = tmp1.next;
                  while (ans.next != null) {
                      ans = ans.next;
                  }
              } else {
                  ans.next = new ListNode(head.val);
                  ans = ans.next;
                  head = head.next;
                  ++cnt;
              }
          }
          return ret.next;
      }
  }
2.7.2.全部翻转（leetcode 206. Reverse Linked List）
  代码：
  class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode ans = new ListNode(-1);
        // ListNode ret = ans;
        while (head != null) {
            ListNode tmp = new ListNode(head.val);
            tmp.next = ans.next;
            ans.next = tmp;
            head = head.next;
        }
        return ans.next;
    }
}
2.7.3.隔k个翻转(leetcode 25. Reverse Nodes in k-Group)
  代码：
  class Solution {
      public ListNode reverseKGroup(ListNode head, int k) {
          if (head == null || head.next == null) {
              return head;
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          while (head != null) {
              int cnt = k;
              ListNode node1 = head;
              // ListNode node1 = head;
              while (cnt > 0 && head != null) {
                  head = head.next;
                  --cnt;
              }
              if (cnt > 0) {
                  ans.next = node1;
                  break;
              } else {
                  head = node1;
                  cnt = k;
                  ListNode t1 = new ListNode(-1);
                  ListNode t2 = t1;
                  while (cnt > 0) {
                      ListNode tmp = new ListNode(head.val);
                      tmp.next = t1.next;
                      t1.next = tmp;
                      head = head.next;
                      --cnt;
                  }
                  ans.next = t2.next;
                  while (ans.next != null) {
                      ans = ans.next;
                  }
              }
          }
          return ret.next;
      }
  }
  
2.8.反转字符串里的单词（leetcode 151. Reverse Words in a String）
  代码：
  class Solution {
    
      private String str;

      public String reverse (int start) {
          if (start >= str.length()) {
              return "";
          }
          StringBuilder cur = new StringBuilder("");
          int i = start;
          for (; i < str.length(); ++i) {
              if (str.charAt(i) != ' ') {
                  cur.append(str.charAt(i));
              } else {
                  break;
              }
          }
          for (; i < str.length(); ++i) {
              if (str.charAt(i) != ' ') {
                  break;
              }
          }
          String next = reverse(i);
          return next.length() == 0 ? cur.toString() : next + " " + cur.toString();
      }

      public String reverseWords(String s) {
          if (s == null || s.length() < 1) {
              return s;
          }
          str = s;
          int i = 0;
          for (; i < str.length(); ++i) {
              if (str.charAt(i) != ' ') {
                  break;
              }
          }
          return reverse(i);
      }
  }
  
2.9.和为s的连续正数序列（剑指offer57-2，滑动窗口）
  代码：
  class Solution {
      public int[][] findContinuousSequence(int target) {
          int start = 1;
          int end = 2;
          int sum = 1;
          List<int[]> ans = new ArrayList<>();
          while (start <= (target/2 + 1)) {
              if (sum == target) {
                  int[] tmp = new int[end - start];
                  int cnt = 0;
                  for (int i = start; i < end; ++i) {
                      tmp[cnt++] = i;
                  }
                  ans.add(tmp);
                  sum -= start;
                  ++start;
              } else if (sum < target) {
                  sum += end;
                  ++end;
              } else {
                  sum -= start;
                  ++start;
              }
          }
          return ans.toArray(new int[ans.size()][]);
      }
  }
  
2.10.递增的三元子序列（leetcode 334. Increasing Triplet Subsequence）
  代码：
  class Solution {
      public boolean increasingTriplet(int[] nums) {
          if (nums == null || nums.length < 3) {
              return false;
          }
          // 保存两个最小值，看是否有第三个数大于这两个值
          int firstMin = Integer.MAX_VALUE;
          int secondMin = Integer.MAX_VALUE;
          for (int num : nums) {
              if (num <= firstMin) {
                  firstMin = num;
              } else if (num <= secondMin) {
                  secondMin = num;
              } else {
                  return true;
              }
          }
          return false;
      }
  }

2.11.下一个排列（leetcode 31. Next Permutation）
  代码：
  class Solution {
    
      public void reverse(int[] arrays, int start, int end) {
          while (start < end) {
              int tmp = arrays[start];
              arrays[start] = arrays[end];
              arrays[end] = tmp;
              ++start;
              --end;
          }
      }


      public void nextPermutation(int[] nums) {
          if (nums == null || nums.length < 1) {
              return;
          }
          int i = nums.length - 2;
          // 从数组最后面开始找第一个降序的位置(nums[i] < nums[i+1])
          while (i >= 0) {
              if (nums[i] < nums[i+1]) {
                  break;
              }
              --i;
          }
          // 整个数组降序，重排
          if (i < 0) {
              reverse(nums, 0, nums.length-1);
              return;
          }
          // 从后面找比nums[i]大的第一个数nums[j], i < j,交换nums[i]、nums[j]两个数，从i+1的位置开始重排
          int j = nums.length - 1;
          while (j > i) {
              if (nums[j] > nums[i]) {
                  break;
              }
              --j;
          }
          int tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
          reverse(nums, i+1, nums.length-1);
      }
  }

2.12.缺失的数字
2.12.1.简单版（leetcode 268. Missing Number）
  代码：
  class Solution {
      public int missingNumber(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          /*
          // 高斯公式
          int n = nums.length;
          int target = n*(n+1)/2;
          for (int num : nums) {
              target -= num;
          }
          return target;
          */
          int n = nums.length;
          for (int i = 0; i < nums.length; ++i) {
              n ^= i ^ nums[i];
          }
          return n;
      }
  }
2.12.2.缺失的第一个正数（leetcode 41. First Missing Positive）
  代码：
  class Solution {
      public int firstMissingPositive(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 1;
          }
          HashSet<Integer> set = new HashSet<>();
          for (int num : nums) {
              set.add(num);
          }
          int n = nums.length;
          for (int i = 1; i <= n; ++i) {
              if (!set.contains(i)) {
                  return i;
              }
          }
          return n+1;
      }
  }
  
2.13.在升序数组中发现数字出现的第一个位置和最后一个位置（leetcode 34. Find First and Last Position of Element in Sorted Array）
  代码：
  class Solution {
      public int[] searchRange(int[] nums, int target) {
          if (nums == null || nums.length < 1) {
              return new int[]{-1, -1};
          }
          int[] ans = new int[2];
          int l = 0;
          int r = nums.length - 1;
          while (l < r) {
              int mid = l + (r-l)/2;
              if (nums[mid] >= target) {
                  r = mid;
              } else {
                  l = mid + 1;
              }
          }
          int a = nums[l] == target ? l : -1;
          l = 0;
          r = nums.length - 1;
          while (l < r) {
              int mid = l + (r-l+1)/2;
              if (nums[mid] <= target) {
                  l = mid;
              } else {
                  r = mid - 1;
              }
          }
          int b = nums[l] == target ? l : -1;
          ans[0] = a;
          ans[1] = b;
          return ans;
      }
  }
  
2.14.数组里的三个数的和是否是0（leetcode 15. 3Sum）
  思路：数组排序；固定一头，剩下两个双指针；去重；
  代码：
  class Solution {
    
      public List<List<Integer>> threeSum(int[] nums) {
          List<List<Integer>> ans = new ArrayList<>();
          if (nums == null || nums.length < 3) {
              return ans;
          }
          Arrays.sort(nums);
          for (int i = 0; i <= nums.length - 3; ++i) {
              if (nums[i] > 0) {
                  break;
              }
              if (i > 0 && nums[i] == nums[i-1]) {
                  continue;
              }
              int sum = nums[i];
              int j = i+1;
              int k = nums.length - 1;
              while (j < k) {
                  int tmp = nums[j] + nums[k];
                  if (tmp + sum == 0) {
                      List<Integer> t = new ArrayList<>();
                      t.add(nums[i]);
                      t.add(nums[j]);
                      t.add(nums[k]);
                      ans.add(t);
                      while (j < k && nums[j] == nums[++j]) {
                          // ++j;
                      }
                      while (j < k && nums[k] == nums[--k]) {
                          // --k;
                      }
                  } else if (tmp + sum < 0) {
                      while (j < k && nums[j] == nums[++j]) {
                          // ++j;
                      }
                  } else {
                      while (j < k && nums[k] == nums[--k]) {
                          // --k;
                      }
                  }
              }
          }
          return ans;
      }
  }
  
2.15.多线程循环打印ABC
  参考：https://paine1690.github.io/post/72391014.html
  代码：
  import java.util.*;
  import java.util.concurrent.Executor;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;

  public class Main3 implements Runnable {

      // 需要不同线程标识
      private static int cnt = 0;
      // 需要锁
      private static Object lock = new Object();
      private int name;

      public Main3 (int v) {
          name = v;
      }

      public void run(){
          try {
              while (true) {
                  synchronized (lock) {
                      while (cnt%3 != name) {
                          lock.wait();
                      }
                      System.out.println((char)('A' + cnt%3));
                      ++cnt;
                      lock.notifyAll();
                  }
              }
          } catch(Exception ex) {
              ex.printStackTrace();
          }

      }
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newFixedThreadPool(3);
          executorService.execute(new Main3(0));
          executorService.execute(new Main3(1));
          executorService.execute(new Main3(2));
      }
  }
  
2.16.以log(m)+log(n)的时间复杂度完成矩阵搜索(leetcode 74. Search a 2D Matrix)
  代码：
  class Solution {
      public boolean searchMatrix(int[][] matrix, int target) {
          if (matrix == null || matrix.length < 1 || matrix[0].length < 1) {
              return false;
          }
          int m = matrix.length;
          int n = matrix[0].length;
          int l = 0;
          int r = m-1;
          while (l < r) {
              int mid = l + (r-l+1)/2;
              if (matrix[mid][0] > target) {
                  r = mid - 1;
              } else {
                  l = mid;
              }
          }
          int row = l;
          l = 0;
          r = n-1;
          while (l < r) {
              int mid = l + (r-l+1)/2;
              if (matrix[row][mid] > target) {
                  r = mid - 1;
              } else {
                  l = mid;
              }
          }
          return matrix[row][l] == target;
      }
  }


