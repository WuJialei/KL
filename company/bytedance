1.参考
链接1：https://www.nowcoder.com/discuss/425581
链接2：https://github.com/lizeyang18/byteDanceAlgorithm

2.重点
2.1.股票买卖
2.2.排序数组，平方后，数组当中有多少不同的数字（相同算一个）
  参考：https://blog.csdn.net/qq_28468707/article/details/103672590?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
  代码：
  public class Main1 {

      public int cntNums (int[] nums) {
          int ans = 0;
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int len = nums.length;
          int l = 0;
          int r = len - 1;
          int preDel = Integer.MAX_VALUE;
          while (l <= r) {
              if (Math.abs(nums[l]) > Math.abs(nums[r])) {
                  if (preDel != Math.abs(nums[l])) {
                      ++ans;
                      preDel = Math.abs(nums[l]);
                  }
                  ++l;
              } else {
                  if (preDel != Math.abs(nums[r])) {
                      ++ans;
                      preDel = Math.abs(nums[r]);
                  }
                  --r;
              }
          }
          return ans;
      }

      public static void main(String[] args) {
          int[] nums = {-5,-3,-1,1,1,2,5};
          Main1 main1 = new Main1();
          int ret = main1.cntNums(nums);
          System.out.println(ret);
      }
  }
变体，先增后减数组的不重复数字个数
  代码：
  public class Main2 {

      public int cntNums (int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int ans = 0;
          int l = 0;
          int r = nums.length-1;
          int preDel = Integer.MAX_VALUE;
          while (l <= r) {
              if (nums[l] < nums[r]) {
                  if (preDel != nums[l]) {
                      ++ans;
                      preDel = nums[l];
                  }
                  ++l;
              } else {
                  if (preDel != nums[r]) {
                      ++ans;
                      preDel = nums[r];
                  }
                  --r;
              }
          }
          return ans;
      }

      public static void main(String[] args) {
          Main2 main2 = new Main2();
          int[] nums= {1, 3, 9, 1};
          int ret = main2.cntNums(nums);
          System.out.println(ret);
      }
  }
  
2.3.写一个函数，求平方根，函数参数为目标数字和精度
  代码：
  public class Main2 {

      public double cntNums (double target, double g) {
          double l = 0;
          double r = target;
          while (r-l > g) {
              double mid = (l+r)/2;
              if (mid * mid < target) {
                  l = mid;
              } else {
                  r = mid;
              }
          }
          return (l+r)/2;
      }

      public static void main(String[] args) {
          Main2 main2 = new Main2();
          int[] nums= {1, 3, 9, 1};
          double ret = main2.cntNums(0.045, 0.001);
          System.out.println(ret);
      }
  }

2.4.链表求和(leetcode 2. Add Two Numbers)
  代码：
  class Solution {
      public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
          if (l1 == null || l2 == null) {
              if (l1 == null && l2 == null) {
                  return null;
              } else if (l1 == null) {
                  return l2;
              } else {
                  return l1;
              }
          }
          ListNode ans = new ListNode(-1);
          ListNode ret = ans;
          int add = 0;
          while (l1 != null && l2 != null) {
              int cur = (l1.val + l2.val + add) % 10;
              add = (l1.val + l2.val + add) / 10;
              ListNode tmp = new ListNode(cur);
              ans.next = tmp;
              ans = ans.next;
              l1 = l1.next;
              l2 = l2.next;
          }
          if (l1 != null || l2 != null) {
              while (l1 != null) {
                  if (add == 0) {
                      ans.next = l1;
                      break;
                  }
                  int cur = (l1.val + add) % 10;
                  add = (l1.val + add) / 10;
                  ListNode tmp = new ListNode(cur);
                  ans.next = tmp;
                  ans = ans.next;
                  l1 = l1.next;
              }
              while (l2 != null) {
                  if (add == 0) {
                      ans.next = l2;
                      break;
                  }
                  int cur = (l2.val + add) % 10;
                  add = (l2.val + add) / 10;
                  ListNode tmp = new ListNode(cur);
                  ans.next = tmp;
                  ans = ans.next;
                  l2 = l2.next;
              }
          }
          if (add > 0) {
              ListNode tmp = new ListNode(add);
              ans.next = tmp;
          }
          return ret.next;
      }
  }
  
2.5.未排序整数数组的最长连续序列长度（leetcode 128. Longest Consecutive Sequence）
  代码：
  class Solution {
      public int longestConsecutive(int[] nums) {
          if (nums == null || nums.length < 1) {
              return 0;
          }
          int ans = 0;
          HashSet<Integer> set = new HashSet<>();
          for (int num : nums) {
              set.add(num);
          }
          for (int num : nums) {
              if (!set.contains(num-1)) {
                  int curAns = 1;
                  while (set.contains(num+1)) {
                      ++curAns;
                      ++num;
                  }
                  ans = Math.max(ans, curAns);
              }
          }
          return ans;
      }
  }
  
2.6.接雨水（leetcode 42. Trapping Rain Water）
  代码：
  class Solution {
      public int trap(int[] height) {
          if (height == null || height.length < 1) {
              return 0;
          }
          int len = height.length;
          // leftH[i]表示第i列左边最高高度，不包括第i列的高度
          // rightH[i]表示第i列右边最高高度，不包括第i列的高度
          // 根据木板效应，装水取决于最短木板，因此比较最短木板与当前水位看是否能够装水
          int[] leftH = new int[len];
          int[] rightH = new int[len];
          for (int i = 1; i < len; ++i) {
              leftH[i] = Math.max(leftH[i-1], height[i-1]);
          }
          for (int j = len-2; j >= 0; --j) {
              rightH[j] = Math.max(rightH[j+1], height[j+1]);
          }
          int ans = 0;
          for (int i = 1; i < len; ++i) {
              int minH = Math.min(leftH[i], rightH[i]);
              if (minH > height[i]) {
                  ans += minH - height[i];
              }
          }
          return ans;
      }
  }

