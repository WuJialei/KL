1.参考
1.1.dfs简述：https://oi-wiki.org/graph/dfs/
1.2.dfs题型分类及模板：https://blog.csdn.net/Chen_yuazzy/article/details/76423134
  地图型第三个，HDU1045 Fire Net（DFS回溯）：https://arminli.com/blog/23
  地图型第四个，奇偶剪枝(步数的偏移量永远为偶数-有来有回,因此可以得出：最短路径步数+偏移量（偶数）=某一可行解歩数，即最短路歩数
  和某一可行解歩数的奇偶性相同)，参考：http://www.slyar.com/blog/depth-first-search-even-odd-pruning.html

2.题型
2.1.树
2.1.1.祖父节点为偶数的所有节点值之和（leetcode [1315] Sum of Nodes with Even-Valued Grandparent）
  代码：
  class Solution {

      private int sum;

      public void dfs (TreeNode node) {
          if (node == null) {
              return;
          }
          if ((node.val & 1) == 0) {
              sum += node.left == null ? 0 : (node.left.left == null ? 0 : node.left.left.val);
              sum += node.left == null ? 0 : (node.left.right == null ? 0 : node.left.right.val);
              sum += node.right == null ? 0 : (node.right.left == null ? 0 : node.right.left.val);
              sum += node.right == null ? 0 : (node.right.right == null ? 0 : node.right.right.val);
          }
          dfs(node.left);
          dfs(node.right);
      }

      public int sumEvenGrandparent(TreeNode root) {
          sum = 0;
          dfs(root);
          return sum;
      }
  }
  
  

商品购买的原价和多种套餐选择问题（leetcode [638] Shopping Offers）
  代码：
  class Solution {
      public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
          int n = price.size();
          int ans = 0;
          for (int i = 0; i < n; ++i) {
              ans += price.get(i) * needs.get(i);
          }
          for (List<Integer> offer : special) {
              boolean flag = true;
              for (int i = 0; i < n; ++i) {
                  if (needs.get(i) - offer.get(i) < 0) {
                      flag = false;
                  }
                  needs.set(i, needs.get(i) - offer.get(i));
              }
              if (flag) {
                  ans = Math.min(ans, offer.get(n) + shoppingOffers(price, special, needs));
              }
              for (int i = 0; i < n; ++i) {
                  needs.set(i, needs.get(i) + offer.get(i));
              }
          }
          return ans;
      }
  }
  
扫雷游戏（leetcode [529] Minesweeper）
  代码：
  class Solution {

      private char[][] ans;
      private int row;
      private int col;
      private int[] dx = {-1, -1, 0, 1, 1, 1, 0, -1};
      private int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};

      public int judge (int a, int b) {
          int num = 0;
          for (int i = 0; i < dx.length; ++i) {
              int aa = a + dx[i];
              int bb = b + dy[i];
              if (aa < 0 || aa >= row || bb < 0 || bb >= col) {
                  continue;
              }
              if (ans[aa][bb] == 'M') {
                  ++num;
              }
          }
          return num;
      }

      public void dfs (int x, int y) {
          if (x < 0 || x >= row || y < 0 || y >= col) {
              return;
          }
          // 判断为E或者M包含了去除已搜索的情况
          if (ans[x][y] == 'E') {
              ans[x][y] = 'B';
              int cnt = judge(x, y);
              if (cnt > 0) {
                  ans[x][y] = (char)('0' + cnt);
              } else {
                  // 为B才能递归
                  for (int i = 0; i < dx.length; ++i) {
                      dfs(x + dx[i], y + dy[i]);
                  }
              }

          } else if (ans[x][y] == 'M') {
              ans[x][y] = 'X';
          }
      }

      public char[][] updateBoard(char[][] board, int[] click) {
          ans = board;
          row = board.length;
          col = board[0].length;
          dfs(click[0], click[1]);
          return ans;
      }
  }
  
  网格路径，一个格子的能往四个方向走的情况是有限制的且下一个格子必须有对接（leetcode [1391] Check if There is a Valid Path in a Grid）
    代码：
    class Solution {

      private int[][] streets = {
          {-1, 1, -1, 1},
          {1, -1, 1, -1},
          {-1, -1,1, 1},
          {-1, 1, 1, -1},
          {1, -1, -1, 1},
          {1, 1, -1, -1}
      };

      private int[] dx = {-1, 0, 1, 0};
      private int[] dy = {0, 1, 0, -1};

      private int[][] g;
      private int m;
      private int n;
      private boolean[][] visited;

      public boolean dfs (int i, int j, int dir) {
          if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) {
              return false;
          }
          if (streets[g[i][j]-1][(dir + 2)%4] == -1) {
              return false;
          }
          if (i == m-1 && j == n-1) {
              return true;
          }
          int t = 0;
          for (; t < dx.length; ++t) {
              if ((streets[g[i][j]-1][t] > -1) && (t != (dir+2)%4)) {
                  break;
              }
          }
          visited[i][j] = true;
          boolean ret = dfs(i + dx[t], j + dy[t], t);
          visited[i][j] = false;
          return ret;
      }

      public boolean hasValidPath(int[][] grid) {
          g = grid;
          m = grid.length;
          n = grid[0].length;
          boolean ans = false;
          int start = g[0][0];
          if (m == 1 && n == 1) {
              return true;
          }
          visited = new boolean[m][n];
          visited[0][0] = true;
          for (int i = 0; i < dx.length; ++i) {
              if (streets[start-1][i] > -1) {
                  if (dfs(dx[i], dy[i], i)){
                      return true;
                  }
              }
          }
          return ans;
      }
  }
  
无向图/有向图中环的判断（leetcode [207] Course Schedule）
  代码：
  class Solution {
    
      HashMap<Integer, List<Integer>> map;
      int[] visited;

      public boolean dfs (int node) {
          visited[node] = 1;
          if (map.containsKey(node)) {
              for (int next : map.get(node)) {
                  if (visited[next] == 1) {
                      return false;
                  } else if (visited[next] == 0) {
                      if(!dfs(next)){
                          return false;
                      }
                  }
              }
          }        
          visited[node] = 2;
          return true;
      }

      public boolean canFinish(int numCourses, int[][] prerequisites) {
          map = new HashMap<>();
          visited = new int[numCourses];
          for (int[] array : prerequisites) {
              int dst = array[0];
              int src = array[1];
              if (!map.containsKey(src)) {
                  map.put(src, new ArrayList<Integer>());
              }
              map.get(src).add(dst);
          }
          for (int key : map.keySet()) {
              if (visited[key] == 0) {
                  if (!dfs(key)) {
                      return false;
                  }
              }
          }
          return true;
      }
  }
变体，利用栈记录路径（leetcode [210] Course Schedule II）
  代码：
  class Solution {

      private HashMap<Integer, List<Integer>> graph;
      private Stack<Integer> stack;
      private int[] visited;

      public boolean dfs (int cur) {
          visited[cur] = 1;
          if (graph.containsKey(cur)) {
              for (int next : graph.get(cur)) {
                  if (visited[next] == 1) {
                      return false;
                  } else if (visited[next] == 0) {
                      if (!dfs(next)) {
                          return false;
                      }
                  }
              }
          }
          visited[cur] = 2;
          stack.push(cur);
          return true;

      }

      public int[] findOrder(int numCourses, int[][] prerequisites) {
          int[] ans = new int[numCourses];
          graph = new HashMap<>();
          stack = new Stack<>();
          visited = new int[numCourses];
          for (int[] array : prerequisites) {
              int dst = array[0];
              int src = array[1];
              if (!graph.containsKey(src)) {
                  graph.put(src, new ArrayList<>());
              }
              graph.get(src).add(dst);
          }
          for (int i = 0; i < numCourses; ++i) {
              if (visited[i] == 0) {
                  if (!dfs(i)) {
                      return new int[]{};
                  }
              }
          }

          int cnt = 0;
          while (!stack.isEmpty()) {
              ans[cnt++] = stack.pop();   
          }
          return ans;

      }


  }
