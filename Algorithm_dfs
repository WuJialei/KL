

商品购买的原价和多种套餐选择问题（leetcode [638] Shopping Offers）
  代码：
  class Solution {
      public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
          int n = price.size();
          int ans = 0;
          for (int i = 0; i < n; ++i) {
              ans += price.get(i) * needs.get(i);
          }
          for (List<Integer> offer : special) {
              boolean flag = true;
              for (int i = 0; i < n; ++i) {
                  if (needs.get(i) - offer.get(i) < 0) {
                      flag = false;
                  }
                  needs.set(i, needs.get(i) - offer.get(i));
              }
              if (flag) {
                  ans = Math.min(ans, offer.get(n) + shoppingOffers(price, special, needs));
              }
              for (int i = 0; i < n; ++i) {
                  needs.set(i, needs.get(i) + offer.get(i));
              }
          }
          return ans;
      }
  }
  
扫雷游戏（leetcode [529] Minesweeper）
  代码：
  class Solution {

      private char[][] ans;
      private int row;
      private int col;
      private int[] dx = {-1, -1, 0, 1, 1, 1, 0, -1};
      private int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};

      public int judge (int a, int b) {
          int num = 0;
          for (int i = 0; i < dx.length; ++i) {
              int aa = a + dx[i];
              int bb = b + dy[i];
              if (aa < 0 || aa >= row || bb < 0 || bb >= col) {
                  continue;
              }
              if (ans[aa][bb] == 'M') {
                  ++num;
              }
          }
          return num;
      }

      public void dfs (int x, int y) {
          if (x < 0 || x >= row || y < 0 || y >= col) {
              return;
          }
          // 判断为E或者M包含了去除已搜索的情况
          if (ans[x][y] == 'E') {
              ans[x][y] = 'B';
              int cnt = judge(x, y);
              if (cnt > 0) {
                  ans[x][y] = (char)('0' + cnt);
              } else {
                  // 为B才能递归
                  for (int i = 0; i < dx.length; ++i) {
                      dfs(x + dx[i], y + dy[i]);
                  }
              }

          } else if (ans[x][y] == 'M') {
              ans[x][y] = 'X';
          }
      }

      public char[][] updateBoard(char[][] board, int[] click) {
          ans = board;
          row = board.length;
          col = board[0].length;
          dfs(click[0], click[1]);
          return ans;
      }
  }
