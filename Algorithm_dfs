

商品购买的原价和多种套餐选择问题（leetcode [638] Shopping Offers）
  代码：
  class Solution {
      public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
          int n = price.size();
          int ans = 0;
          for (int i = 0; i < n; ++i) {
              ans += price.get(i) * needs.get(i);
          }
          for (List<Integer> offer : special) {
              boolean flag = true;
              for (int i = 0; i < n; ++i) {
                  if (needs.get(i) - offer.get(i) < 0) {
                      flag = false;
                  }
                  needs.set(i, needs.get(i) - offer.get(i));
              }
              if (flag) {
                  ans = Math.min(ans, offer.get(n) + shoppingOffers(price, special, needs));
              }
              for (int i = 0; i < n; ++i) {
                  needs.set(i, needs.get(i) + offer.get(i));
              }
          }
          return ans;
      }
  }
  
扫雷游戏（leetcode [529] Minesweeper）
  代码：
  class Solution {

      private char[][] ans;
      private int row;
      private int col;
      private int[] dx = {-1, -1, 0, 1, 1, 1, 0, -1};
      private int[] dy = {0, 1, 1, 1, 0, -1, -1, -1};

      public int judge (int a, int b) {
          int num = 0;
          for (int i = 0; i < dx.length; ++i) {
              int aa = a + dx[i];
              int bb = b + dy[i];
              if (aa < 0 || aa >= row || bb < 0 || bb >= col) {
                  continue;
              }
              if (ans[aa][bb] == 'M') {
                  ++num;
              }
          }
          return num;
      }

      public void dfs (int x, int y) {
          if (x < 0 || x >= row || y < 0 || y >= col) {
              return;
          }
          // 判断为E或者M包含了去除已搜索的情况
          if (ans[x][y] == 'E') {
              ans[x][y] = 'B';
              int cnt = judge(x, y);
              if (cnt > 0) {
                  ans[x][y] = (char)('0' + cnt);
              } else {
                  // 为B才能递归
                  for (int i = 0; i < dx.length; ++i) {
                      dfs(x + dx[i], y + dy[i]);
                  }
              }

          } else if (ans[x][y] == 'M') {
              ans[x][y] = 'X';
          }
      }

      public char[][] updateBoard(char[][] board, int[] click) {
          ans = board;
          row = board.length;
          col = board[0].length;
          dfs(click[0], click[1]);
          return ans;
      }
  }
  
  网格路径，一个格子的能往四个方向走的情况是有限制的且下一个格子必须有对接（leetcode [1391] Check if There is a Valid Path in a Grid）
    代码：
    class Solution {

      private int[][] streets = {
          {-1, 1, -1, 1},
          {1, -1, 1, -1},
          {-1, -1,1, 1},
          {-1, 1, 1, -1},
          {1, -1, -1, 1},
          {1, 1, -1, -1}
      };

      private int[] dx = {-1, 0, 1, 0};
      private int[] dy = {0, 1, 0, -1};

      private int[][] g;
      private int m;
      private int n;
      private boolean[][] visited;

      public boolean dfs (int i, int j, int dir) {
          if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) {
              return false;
          }
          if (streets[g[i][j]-1][(dir + 2)%4] == -1) {
              return false;
          }
          if (i == m-1 && j == n-1) {
              return true;
          }
          int t = 0;
          for (; t < dx.length; ++t) {
              if ((streets[g[i][j]-1][t] > -1) && (t != (dir+2)%4)) {
                  break;
              }
          }
          visited[i][j] = true;
          boolean ret = dfs(i + dx[t], j + dy[t], t);
          visited[i][j] = false;
          return ret;
      }

      public boolean hasValidPath(int[][] grid) {
          g = grid;
          m = grid.length;
          n = grid[0].length;
          boolean ans = false;
          int start = g[0][0];
          if (m == 1 && n == 1) {
              return true;
          }
          visited = new boolean[m][n];
          visited[0][0] = true;
          for (int i = 0; i < dx.length; ++i) {
              if (streets[start-1][i] > -1) {
                  if (dfs(dx[i], dy[i], i)){
                      return true;
                  }
              }
          }
          return ans;
      }
  }
  
无向图/有向图中环的判断（leetcode [207] Course Schedule）
  代码：
  class Solution {
    
      HashMap<Integer, List<Integer>> map;
      int[] visited;

      public boolean dfs (int node) {
          visited[node] = 1;
          if (map.containsKey(node)) {
              for (int next : map.get(node)) {
                  if (visited[next] == 1) {
                      return false;
                  } else if (visited[next] == 0) {
                      if(!dfs(next)){
                          return false;
                      }
                  }
              }
          }        
          visited[node] = 2;
          return true;
      }

      public boolean canFinish(int numCourses, int[][] prerequisites) {
          map = new HashMap<>();
          visited = new int[numCourses];
          for (int[] array : prerequisites) {
              int dst = array[0];
              int src = array[1];
              if (!map.containsKey(src)) {
                  map.put(src, new ArrayList<Integer>());
              }
              map.get(src).add(dst);
          }
          for (int key : map.keySet()) {
              if (visited[key] == 0) {
                  if (!dfs(key)) {
                      return false;
                  }
              }
          }
          return true;
      }
  }
