1.参考：https://www.cnblogs.com/nxf-rabbit75/p/10008297.html#auto_id_0
  注意点：
  a.引入头结点对链表最后的表示很有帮助；
  b.链表结点访问next之前要判空，复杂代码里需要多加留意注意；
  1.1.链表的翻转(leetcode 206. Reverse Linked List)
      头插法(非递归)：
      class Solution {
          public ListNode reverseList(ListNode head) {
              if (head == null || head.next == null) {
                  return head;
              }
              ListNode newHead = null;
              ListNode temp = null;
              while (head != null) {
                  temp = head.next;
                  head.next = newHead;
                  newHead = head;
                  head = temp;
              }
              return newHead;
          }
      }
      递归：
      class Solution {
          public ListNode reverseList(ListNode head) {
              if (head == null || head.next == null) {
                  return head;
              }
              ListNode newHead = reverseList(head.next);
              head.next.next = head;
              head.next = null;
              return newHead;
          }
      }
  1.2.有序链表的合并(leetcode 21. Merge Two Sorted Lists)
      非递归：
      class Solution {
          public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if (l1 == null) {
            return l2;
          }
          if (l2 == null) {
            return l1;
          }
          ListNode p = new ListNode(0);
          ListNode ans = p;
          while (l1 != null && l2 != null) {
                  if (l1.val < l2.val) {
                      p.next = new ListNode(l1.val);
                      l1 = l1.next;
                  } else {
                      p.next = new ListNode(l2.val);
                      l2 = l2.next;
                  }
            p = p.next;
          }
          if (l1 != null) {
            p.next = l1;
          }
          if (l2 != null) {
            p.next = l2;
          }
          return ans.next;
          }
      }
      递归：
      class Solution {
          public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if (l1 == null) {
            return l2;
          }
          if (l2 == null) {
            return l1;
          }
          if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
          } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
          }
          }
      }
      1.3.链表的去重(leetcode 83. Remove Duplicates from Sorted List)
      class Solution {
          public ListNode deleteDuplicates(ListNode head) {
              if (head == null || head.next == null) {
                  return head;
              }
              ListNode p = new ListNode(0);
              p.next = head;
              ListNode pre = head;
              ListNode cur = head.next;
              while (cur != null) {
                  while(cur != null && cur.val == pre.val) {
                      cur = cur.next;
                  }
                  pre.next = cur;
                  pre = pre.next;
                  cur = cur != null ? cur.next : null;
              }
              return p.next;
          }
      }
      
      
