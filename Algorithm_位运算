1.参考
1.1.https://oi-wiki.org/math/bit/
1.2.n&(n-1)的用法(将最低位的1变为0)：https://blog.csdn.net/navyifanr/article/details/19496459

2.应用
2.1.异或
2.1.1.汉明距离(leetcode [461] Hamming Distance)
  代码：
  class Solution {
      public int hammingDistance(int x, int y) {
          int tmp = x ^ y;
          int ans = 0;
          int cnt = 32;
          while (cnt > 0) {
              if ((tmp & 1) == 1) {
                  ++ans;
              }
              tmp >>= 1;
              --cnt;
          }
          return ans;
      }
  }
变体，数(含负数)的1的个数（[191] Number of 1 Bits）
  代码：
  public class Solution {
      // you need to treat n as an unsigned value
      public int hammingWeight(int n) {
          int ans = 0;
          int cnt = 32;
          while (cnt > 0) {
              if ((n & 1) == 1) {
                  ++ans;
              }
              --cnt;
              n >>= 1;
          }
          return ans;
      }
  }
2.1.2.数字的补数（leetcode [476] Number Complement）
    代码：
    class Solution {
        public int findComplement(int num) {
            int i = 1;
            int cur = 0;
            // 找高位第一为1的位数，与全1异或
            while (num > 0) {
                cur = ((num & 1) ^ 1)* i + cur;
                i <<= 1;
                num >>= 1;
            }
            return cur;
        }
    }
变体，二进制手表([401] Binary Watch)
  思路：Integer.bitCount()计算数中二进制1的个数
  代码：
  class Solution {
      public List<String> readBinaryWatch(int num) {
          List<String> ans = new ArrayList<>();
          for (int hour = 0; hour < 12; ++hour) {
              for (int minute = 0; minute < 60; ++minute) {
                  if (Integer.bitCount(hour) + Integer.bitCount(minute) == num) {
                      ans.add(String.format("%d:%02d", hour, minute));
                  }
              }
          }
          return ans;
      }
  }
2.1.3.缺失数字（[268] Missing Number）
   代码：
   class Solution {
      public int missingNumber(int[] nums) {
          if (nums == null || nums.length < 1) {

          }
          int ans = 0;
          for (int i = 0; i < nums.length; ++i) {
              ans ^= i ^ nums[i];
          }
          ans ^= nums.length;
          return ans;
      }
  }
2.1.4.形成两个异或相等数组的连续的三元组数目(leetcode 1442. Count Triplets That Can Form Two Arrays of Equal XOR)
  代码：
  class Solution {
      public int countTriplets(int[] arr) {
          // a = b <=> a ^ b = 0
          if (arr == null || arr.length < 1) {
              return 0;
          }
          int ans = 0;
          for (int i = 0; i < arr.length; ++i) {
              int tmp = arr[i];
              for (int k = i + 1; k < arr.length; ++k) {
                  tmp ^= arr[k];
                  if (tmp == 0) {
                      ans += k - i;
                  }
              }
          }
          return ans;
      }
  }
2.1.5.二叉树中的伪字符串（1457. Pseudo-Palindromic Paths in a Binary Tree）
  代码：
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      int ans = 0;
      public int pseudoPalindromicPaths (TreeNode root) {
          if (root == null) return 0;
          int nums = 0;
          dfs(root, nums);
          return ans;
      }

      public void dfs(TreeNode root, int temp) {
          int n = temp ^ (1 << root.val);
          if (root.left == null && root.right == null) {
              if (n == 0 || (n & (n - 1)) == 0) {
                  ++ans;
              }
              return;
          }
          if (root.left != null) {
              dfs(root.left, n);
          }
          if (root.right != null) {
              dfs(root.right, n);
          }
      }
  }

  
2.2.动态规划
2.2.1.0到n的每个数中二进制表示的1的位数O(n)计算得到（[338] Counting Bits）
  代码：
  class Solution {
      public int[] countBits(int num) {
          int[] dp = new int[num + 1];
          dp[0] = 0;
          if (num >= 1) {
              dp[1] = 1;
              for (int i = 2; i <= num; ++i) {
                  dp[i] = dp[i >> 1] + (i&1);
              }
          }
          return dp;
      }
  }
  

