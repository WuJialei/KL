1.参考：https://oi-wiki.org/graph/bfs/
1.1.bfs基本使用
1.2.记录最短路径序列
1.3.记录最短路径长度
1.4.优先级队列
1.5.双端bfs？

2.1树
2.1.1.n叉树的深度（leetcode [559] Maximum Depth of N-ary Tree）
  代码：
  class Solution {
      public int maxDepth(Node root) {
          return bfs(root);
          // return depth(root);
      }

      public int bfs (Node node) {
          if (node == null) {
              return 0;
          }
          Queue<Node> queue = new LinkedList<>();
          queue.offer(node);
          int ans = 0;
          while (!queue.isEmpty()) {
              ++ans;
              Queue<Node> temp = new LinkedList<>();
              while (!queue.isEmpty()) {
                  Node cur = queue.poll();
                  for (Node child : cur.children) {
                      temp.offer(child);
                  }
              }
              queue = temp;
          }
          return ans;

      }

      public int depth(Node node) {
          if (node == null) {
              return 0;
          } else if (node.children == null) {
              return 1;
          } else {
              int ans = 0;
              for (Node child : node.children) {
                  ans = Math.max(ans, depth(child));
              }
              return ans + 1;
          }

      }

  }
2.1.2.判断是否是堂兄弟节点（leetcode [993] Cousins in Binary Tree）
  代码：
  class Solution {

      // Map<Integer, TreeNode> parent;
      // Map<Integer, Integer> depth;

      public boolean isCousins(TreeNode root, int x, int y) {

          Queue<TreeNode> queue = new LinkedList<>();
          if (root == null) {
              return false;
          }
          if (root.val == x || root.val == y) {
              return false;
          }
          queue.offer(root);
          while (!queue.isEmpty()) {
              Queue<TreeNode> temp = new LinkedList<>();
              boolean xFlag = false;
              boolean yFlag = false;
              int xParent = -1;
              int yParent = -1;
              while (!queue.isEmpty()) {
                  TreeNode node = queue.poll();
                  if (node.left != null) {
                      temp.offer(node.left);
                      if (node.left.val == x) {
                          xFlag = true;
                          xParent = node.val;
                      } else if (node.left.val == y) {
                          yFlag = true;
                          yParent = node.val;
                      }
                  }
                  if (node.right != null) {
                      temp.offer(node.right);
                      if (node.right.val == x) {
                          xFlag = true;
                          xParent = node.val;
                      } else if (node.right.val == y) {
                          yFlag = true;
                          yParent = node.val;
                      }
                  }
              }
              if (xFlag || yFlag) {
                  if (xFlag && yFlag) {
                      return xParent == yParent ? false : true;
                  }
                  return false;
              }
              queue = temp;
          }
          return false;

          // parent = new HashMap<Integer, TreeNode>();
          // depth = new HashMap<Integer, Integer>();
          // dfs(new TreeNode(-1), root, 0);
          // return depth.get(x) == depth.get(y) && parent.get(x) != parent.get(y);

      }

      // public void dfs (TreeNode pre, TreeNode node, int cnt) {
      //     if (node == null) {
      //         return;
      //     }
      //     depth.put(node.val, cnt);
      //     parent.put(node.val, pre);
      //     dfs(node, node.left, cnt + 1);
      //     dfs(node, node.right, cnt + 1);
      // }

  }

