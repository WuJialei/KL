1.参考：https://oi-wiki.org/graph/bfs/
1.1.bfs基本使用
1.2.记录最短路径序列
1.3.记录最短路径长度
1.4.优先级队列
1.5.双端bfs？

2.1树
2.1.1.n叉树的深度（leetcode [559] Maximum Depth of N-ary Tree）
  代码：
  class Solution {
      public int maxDepth(Node root) {
          return bfs(root);
          // return depth(root);
      }

      public int bfs (Node node) {
          if (node == null) {
              return 0;
          }
          Queue<Node> queue = new LinkedList<>();
          queue.offer(node);
          int ans = 0;
          while (!queue.isEmpty()) {
              ++ans;
              Queue<Node> temp = new LinkedList<>();
              while (!queue.isEmpty()) {
                  Node cur = queue.poll();
                  for (Node child : cur.children) {
                      temp.offer(child);
                  }
              }
              queue = temp;
          }
          return ans;

      }

      public int depth(Node node) {
          if (node == null) {
              return 0;
          } else if (node.children == null) {
              return 1;
          } else {
              int ans = 0;
              for (Node child : node.children) {
                  ans = Math.max(ans, depth(child));
              }
              return ans + 1;
          }

      }

  }
2.1.2.判断是否是堂兄弟节点（leetcode [993] Cousins in Binary Tree）
  代码：
  class Solution {

      // Map<Integer, TreeNode> parent;
      // Map<Integer, Integer> depth;

      public boolean isCousins(TreeNode root, int x, int y) {

          Queue<TreeNode> queue = new LinkedList<>();
          if (root == null) {
              return false;
          }
          if (root.val == x || root.val == y) {
              return false;
          }
          queue.offer(root);
          while (!queue.isEmpty()) {
              Queue<TreeNode> temp = new LinkedList<>();
              boolean xFlag = false;
              boolean yFlag = false;
              int xParent = -1;
              int yParent = -1;
              while (!queue.isEmpty()) {
                  TreeNode node = queue.poll();
                  if (node.left != null) {
                      temp.offer(node.left);
                      if (node.left.val == x) {
                          xFlag = true;
                          xParent = node.val;
                      } else if (node.left.val == y) {
                          yFlag = true;
                          yParent = node.val;
                      }
                  }
                  if (node.right != null) {
                      temp.offer(node.right);
                      if (node.right.val == x) {
                          xFlag = true;
                          xParent = node.val;
                      } else if (node.right.val == y) {
                          yFlag = true;
                          yParent = node.val;
                      }
                  }
              }
              if (xFlag || yFlag) {
                  if (xFlag && yFlag) {
                      return xParent == yParent ? false : true;
                  }
                  return false;
              }
              queue = temp;
          }
          return false;

          // parent = new HashMap<Integer, TreeNode>();
          // depth = new HashMap<Integer, Integer>();
          // dfs(new TreeNode(-1), root, 0);
          // return depth.get(x) == depth.get(y) && parent.get(x) != parent.get(y);

      }

      // public void dfs (TreeNode pre, TreeNode node, int cnt) {
      //     if (node == null) {
      //         return;
      //     }
      //     depth.put(node.val, cnt);
      //     parent.put(node.val, pre);
      //     dfs(node, node.left, cnt + 1);
      //     dfs(node, node.right, cnt + 1);
      // }

  }
2.1.3.二叉树中到指定节点距离为k的节点查找（leetcode [863] All Nodes Distance K in Binary Tree）
  代码：
  class Solution {

      private HashMap<TreeNode, TreeNode> parent;
      private List<Integer> ans;
      private boolean[] visited;

      public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
          parent = new HashMap<>();
          ans = new ArrayList<>();
          visited = new boolean[1005];
          if (root == null) {
              return ans;
          }
          Queue<TreeNode> queue = new LinkedList<>();
          queue.offer(root);
          parent.put(root, new TreeNode(-1));
          TreeNode tNode = new TreeNode(-1);
          boolean flag = false;
          // 按层遍历，寻找目标节点，并且记录节点的父节点
          while (!queue.isEmpty()) {
              Queue<TreeNode> temp = new LinkedList<>();
              while (!queue.isEmpty()) {
                  TreeNode node = queue.poll();
                  if (node.val == target.val) {
                      tNode = node;
                      flag = true;
                      break;
                  }
                  if (node.left != null) {
                      parent.put(node.left, node);
                      temp.offer(node.left);
                  }
                  if (node.right != null) {
                      parent.put(node.right, node);
                      temp.offer(node.right);
                  }
              }
              if (flag) {
                  break;
              }
              queue.addAll(temp);
          }
          int k = K;
          // 寻找目标节点的子节点里的k距离值
          dfs(tNode, k);
          int cnt = K;
          visited[tNode.val] = true;
          // 依次寻找目标节点的父节点里的k距离值，注意记忆化去重
          while (cnt > 0 && parent.get(tNode).val != -1) {
              tNode = parent.get(tNode);
              dfs(tNode, --cnt);
              visited[tNode.val] = true;
          }
          return ans;
      }

      public void dfs (TreeNode node, int num) {
          if (node == null || num < 0 || visited[node.val]) {
              return;
          }
          if (num == 0) {
              ans.add(node.val);
          }
          dfs(node.left, num-1);
          dfs(node.right, num-1);
      }

  }

