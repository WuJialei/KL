1.二叉树的下一个节点（8）
  代码：
  /*
  public class TreeLinkNode {
      int val;
      TreeLinkNode left = null;
      TreeLinkNode right = null;
      TreeLinkNode next = null;

      TreeLinkNode(int val) {
          this.val = val;
      }
  }
  */
  public class Solution {
      public TreeLinkNode GetNext(TreeLinkNode pNode)
      {
          if (pNode == null) {
              return null;
          }
          TreeLinkNode ans = null;
          if (pNode.right != null) {
              // pNode有右子树，一直往左
              TreeLinkNode node = pNode.right;
              while (node != null && node.left != null) {
                  node = node.left;
              }
              ans = node;
          } else if (pNode.next != null) {
              // pNode没有右子树，找第一个是其父节点的左节点的节点，其父节点即为下一个节点
              TreeLinkNode cur = pNode;
              TreeLinkNode pre = pNode.next;
              while (pre != null && cur == pre.right) {
                  cur = pre;
                  pre = pre.next;
              }
              ans = cur.next;
          }
          return ans;
      }
  }
  
2.用两个栈实现队列（9）
  代码：
  public class Solution {
      Stack<Integer> stack1 = new Stack<Integer>();
      Stack<Integer> stack2 = new Stack<Integer>();

      public void push(int node) {
          stack1.push(node);
      }

      public int pop() {
          if (stack2.isEmpty()) {
              while(!stack1.isEmpty()) {
                  stack2.push(stack1.pop());
              }
          } 
          return stack2.pop();
      }
  }
