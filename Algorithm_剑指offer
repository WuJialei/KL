1.二叉树的下一个节点（8）
  代码：
  /*
  public class TreeLinkNode {
      int val;
      TreeLinkNode left = null;
      TreeLinkNode right = null;
      TreeLinkNode next = null;

      TreeLinkNode(int val) {
          this.val = val;
      }
  }
  */
  public class Solution {
      public TreeLinkNode GetNext(TreeLinkNode pNode)
      {
          if (pNode == null) {
              return null;
          }
          TreeLinkNode ans = null;
          if (pNode.right != null) {
              // pNode有右子树，一直往左
              TreeLinkNode node = pNode.right;
              while (node != null && node.left != null) {
                  node = node.left;
              }
              ans = node;
          } else if (pNode.next != null) {
              // pNode没有右子树，找第一个是其父节点的左节点的节点，其父节点即为下一个节点
              TreeLinkNode cur = pNode;
              TreeLinkNode pre = pNode.next;
              while (pre != null && cur == pre.right) {
                  cur = pre;
                  pre = pre.next;
              }
              ans = cur.next;
          }
          return ans;
      }
  }
  
2.用两个栈实现队列（9）
  代码：
  public class Solution {
      Stack<Integer> stack1 = new Stack<Integer>();
      Stack<Integer> stack2 = new Stack<Integer>();

      public void push(int node) {
          stack1.push(node);
      }

      public int pop() {
          if (stack2.isEmpty()) {
              while(!stack1.isEmpty()) {
                  stack2.push(stack1.pop());
              }
          } 
          return stack2.pop();
      }
  }
相关（两个队列实现一个栈，leetcode 225. Implement Stack using Queues）
  代码：
  class MyStack {
  
      private Queue<Integer> inQueue;
      private Queue<Integer> outQueue;

      /** Initialize your data structure here. */
      public MyStack() {
          inQueue = new LinkedList<>();
          outQueue = new LinkedList<>();
      }

      /** Push element x onto stack. */
      public void push(int x) {
          // 保持inQueue为空，元素都在outQueue
          // 每次inQueue入队列，然后inQueue屁股后面加所有的outQueue
          // 再把所有的inQueue输入到outQueue，类似于头插法
          inQueue.offer(x);
          while (!outQueue.isEmpty()) {
              inQueue.offer(outQueue.poll());
          }
          while (!inQueue.isEmpty()) {
              outQueue.offer(inQueue.poll());
          }
      }

      /** Removes the element on top of the stack and returns that element. */
      public int pop() {
          return outQueue.poll();
      }

      /** Get the top element. */
      public int top() {
          return outQueue.peek();
      }

      /** Returns whether the stack is empty. */
      public boolean empty() {
          return outQueue.isEmpty();
      }
  }

  /**
   * Your MyStack object will be instantiated and called as such:
   * MyStack obj = new MyStack();
   * obj.push(x);
   * int param_2 = obj.pop();
   * int param_3 = obj.top();
   * boolean param_4 = obj.empty();
   */
   
 3.斐波那契数列的变体（10）
 3.1.青蛙变态跳问题
  思路：
  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
  分析：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级
    跳1级，剩下n-1级，则剩下跳法是f(n-1)
    跳2级，剩下n-2级，则剩下跳法是f(n-2)
    所以f(n) = f(n-1) + f(n-2) + ... + f(1)
    因为f(n-1) = f(n-2) + f(n-3 )+ ... + f(1)
    所以f(n) = 2 * f(n-1)。
    根据f(1) = 1，f(n) = 2 * f(n-1)，可以得出f(n) = 2^(n-1)。
  或者可以这么分析：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)种情况。
3.2.矩形放置问题
  用2*1的矩形去覆盖2*n的矩形，求方案数目
  第一步考虑横着放还是竖着放，f(n) = f(n-1) + f(n-2)
  
4.旋转数组的最小数字（11）
  代码：
  public class Solution {
      public int minNumberInRotateArray(int [] array) {
          if (array == null || array.length < 1) {
              return 0;
          }
          int left = 0;
          int right = array.length - 1;
          while (left < right) {
              int mid = left + (right - left)/2;
              if (array[mid] < array[right]) {
                  right = mid;
              } else if (array[mid] == array[right]) {
                  --right;
              } else {
                  left = mid + 1;
              }
          }
          return array[left];
      }
  }

5.剪绳子（14）
  代码：
  public class Solution {
      public int cutRope(int target) {
          int len = target + 1;
          int[] dp = new int[len];
          if (target < 2) {
              return 0;
          } else if (target == 2) {
              return 1;
          } else if (target == 3) {
              return 2;
          }
          // dp[i]表示必须剪一下
          dp[0] = 0;
          dp[1] = 0;
          dp[2] = 1;
          dp[3] = 2;
          for (int i = 4; i <= target; ++i) {
              int max = 0;
              for (int j = 1; j <= i/2 + 1; ++j) {
                  max = Math.max(max, dp[j] * dp[i-j]);
                  max = Math.max(max, j * (i-j));
              }
              dp[i] = max;
          }
          return dp[target];
      }
  }
  
6.以O(log(n))解决数值的整数次方（16）
  代码：
  public class Solution {
    
      public double dfs (double num, int cnt) {
          if (cnt == 0) {
              return 1;
          } else if (cnt == 1) {
              return num;
          }
          double tmp = dfs(num, cnt >> 1);
          tmp *= tmp;
          if ((cnt & 1) == 1) {
              tmp *= num;
          }
          return tmp;
      }

      public double Power(double base, int exponent) {
          double ans = 1;
          boolean flag = false;
          if (exponent < 0) {
              flag = true;
              exponent = 0 - exponent;
          }
          /*
          while (exponent > 0) {
              ans *= base;
              --exponent;
          }
          */
          ans = dfs(base, exponent);
          return flag ? 1/ans : ans;
    }

  }

7.链表中重复的节点完全删除（18）
  代码：
  /*
   public class ListNode {
      int val;
      ListNode next = null;

      ListNode(int val) {
          this.val = val;
      }
  }
  */
  public class Solution {
      public ListNode deleteDuplication(ListNode pHead)
      {
          if (pHead == null || pHead.next == null) {
              return pHead;
          }
          ListNode p = new ListNode(-1);
          p.next = pHead;
          ListNode pre = p;
          ListNode cur = pre.next;
          while (cur != null) {
              boolean flag = false;
              // 先试探步，确保要加入链的下一个值不是重复值
              while (cur != null && cur.next != null && cur.val == cur.next.val) {
                  flag = true;
                  cur = cur.next;
              }
              if (flag) {
                  pre.next = cur == null ? null : cur.next;
                  cur = pre.next;
              } else {
                  pre.next = cur;
                  pre = pre.next;
                  cur = cur == null ? null : cur.next;
              }
          }
          return p.next;
      }
  }
  
8.正则表达式的匹配（19）
  代码：
  public class Solution {
      public boolean match(char[] str, char[] pattern) {
      if (str == null || pattern == null) {
          return false;
      }
      int strIndex = 0;
      int patternIndex = 0;
      return matchCore(str, strIndex, pattern, patternIndex);
  }

  public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
      //有效性检验：str到尾，pattern到尾，匹配成功
      if (strIndex == str.length && patternIndex == pattern.length) {
          return true;
      }
      //pattern先到尾，匹配失败
      if (strIndex != str.length && patternIndex == pattern.length) {
          return false;
      }
      //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
      if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
          if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
              return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
                      || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
                      || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
          } else {
              return matchCore(str, strIndex, pattern, patternIndex + 2);
          }
      }
      //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
      if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
          return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
      }
      return false;
      }
  }
