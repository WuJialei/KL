1.二叉树的下一个节点（8）
  代码：
  /*
  public class TreeLinkNode {
      int val;
      TreeLinkNode left = null;
      TreeLinkNode right = null;
      TreeLinkNode next = null;

      TreeLinkNode(int val) {
          this.val = val;
      }
  }
  */
  public class Solution {
      public TreeLinkNode GetNext(TreeLinkNode pNode)
      {
          if (pNode == null) {
              return null;
          }
          TreeLinkNode ans = null;
          if (pNode.right != null) {
              // pNode有右子树，一直往左
              TreeLinkNode node = pNode.right;
              while (node != null && node.left != null) {
                  node = node.left;
              }
              ans = node;
          } else if (pNode.next != null) {
              // pNode没有右子树，找第一个是其父节点的左节点的节点，其父节点即为下一个节点
              TreeLinkNode cur = pNode;
              TreeLinkNode pre = pNode.next;
              while (pre != null && cur == pre.right) {
                  cur = pre;
                  pre = pre.next;
              }
              ans = cur.next;
          }
          return ans;
      }
  }
  
2.用两个栈实现队列（9）
  代码：
  public class Solution {
      Stack<Integer> stack1 = new Stack<Integer>();
      Stack<Integer> stack2 = new Stack<Integer>();

      public void push(int node) {
          stack1.push(node);
      }

      public int pop() {
          if (stack2.isEmpty()) {
              while(!stack1.isEmpty()) {
                  stack2.push(stack1.pop());
              }
          } 
          return stack2.pop();
      }
  }
相关（两个队列实现一个栈，leetcode 225. Implement Stack using Queues）
  代码：
  class MyStack {
  
      private Queue<Integer> inQueue;
      private Queue<Integer> outQueue;

      /** Initialize your data structure here. */
      public MyStack() {
          inQueue = new LinkedList<>();
          outQueue = new LinkedList<>();
      }

      /** Push element x onto stack. */
      public void push(int x) {
          // 保持inQueue为空，元素都在outQueue
          // 每次inQueue入队列，然后inQueue屁股后面加所有的outQueue
          // 再把所有的inQueue输入到outQueue，类似于头插法
          inQueue.offer(x);
          while (!outQueue.isEmpty()) {
              inQueue.offer(outQueue.poll());
          }
          while (!inQueue.isEmpty()) {
              outQueue.offer(inQueue.poll());
          }
      }

      /** Removes the element on top of the stack and returns that element. */
      public int pop() {
          return outQueue.poll();
      }

      /** Get the top element. */
      public int top() {
          return outQueue.peek();
      }

      /** Returns whether the stack is empty. */
      public boolean empty() {
          return outQueue.isEmpty();
      }
  }

  /**
   * Your MyStack object will be instantiated and called as such:
   * MyStack obj = new MyStack();
   * obj.push(x);
   * int param_2 = obj.pop();
   * int param_3 = obj.top();
   * boolean param_4 = obj.empty();
   */
   
 3.斐波那契数列的变体（10）
 3.1.青蛙变态跳问题
  思路：
  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
  分析：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级
    跳1级，剩下n-1级，则剩下跳法是f(n-1)
    跳2级，剩下n-2级，则剩下跳法是f(n-2)
    所以f(n) = f(n-1) + f(n-2) + ... + f(1)
    因为f(n-1) = f(n-2) + f(n-3 )+ ... + f(1)
    所以f(n) = 2 * f(n-1)。
    根据f(1) = 1，f(n) = 2 * f(n-1)，可以得出f(n) = 2^(n-1)。
  或者可以这么分析：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)种情况。
3.2.矩形放置问题
  用2*1的矩形去覆盖2*n的矩形，求方案数目
  第一步考虑横着放还是竖着放，f(n) = f(n-1) + f(n-2)
  
4.旋转数组的最小数字（11）
  代码：
  public class Solution {
      public int minNumberInRotateArray(int [] array) {
          if (array == null || array.length < 1) {
              return 0;
          }
          int left = 0;
          int right = array.length - 1;
          while (left < right) {
              int mid = left + (right - left)/2;
              if (array[mid] < array[right]) {
                  right = mid;
              } else if (array[mid] == array[right]) {
                  --right;
              } else {
                  left = mid + 1;
              }
          }
          return array[left];
      }
  }

5.剪绳子（14）
  代码：
  public class Solution {
      public int cutRope(int target) {
          int len = target + 1;
          int[] dp = new int[len];
          if (target < 2) {
              return 0;
          } else if (target == 2) {
              return 1;
          } else if (target == 3) {
              return 2;
          }
          // dp[i]表示必须剪一下
          dp[0] = 0;
          dp[1] = 0;
          dp[2] = 1;
          dp[3] = 2;
          for (int i = 4; i <= target; ++i) {
              int max = 0;
              for (int j = 1; j <= i/2 + 1; ++j) {
                  max = Math.max(max, dp[j] * dp[i-j]);
                  max = Math.max(max, j * (i-j));
              }
              dp[i] = max;
          }
          return dp[target];
      }
  }
  
6.以O(log(n))解决数值的整数次方（16）
  代码：
  public class Solution {
    
      public double dfs (double num, int cnt) {
          if (cnt == 0) {
              return 1;
          } else if (cnt == 1) {
              return num;
          }
          double tmp = dfs(num, cnt >> 1);
          tmp *= tmp;
          if ((cnt & 1) == 1) {
              tmp *= num;
          }
          return tmp;
      }

      public double Power(double base, int exponent) {
          double ans = 1;
          boolean flag = false;
          if (exponent < 0) {
              flag = true;
              exponent = 0 - exponent;
          }
          /*
          while (exponent > 0) {
              ans *= base;
              --exponent;
          }
          */
          ans = dfs(base, exponent);
          return flag ? 1/ans : ans;
    }

  }

7.链表中重复的节点完全删除（18）
  代码：
  /*
   public class ListNode {
      int val;
      ListNode next = null;

      ListNode(int val) {
          this.val = val;
      }
  }
  */
  public class Solution {
      public ListNode deleteDuplication(ListNode pHead)
      {
          if (pHead == null || pHead.next == null) {
              return pHead;
          }
          ListNode p = new ListNode(-1);
          p.next = pHead;
          ListNode pre = p;
          ListNode cur = pre.next;
          while (cur != null) {
              boolean flag = false;
              // 先试探步，确保要加入链的下一个值不是重复值
              while (cur != null && cur.next != null && cur.val == cur.next.val) {
                  flag = true;
                  cur = cur.next;
              }
              if (flag) {
                  pre.next = cur == null ? null : cur.next;
                  cur = pre.next;
              } else {
                  pre.next = cur;
                  pre = pre.next;
                  cur = cur == null ? null : cur.next;
              }
          }
          return p.next;
      }
  }
  
8.正则表达式的匹配（19）
  代码：
  public class Solution {
      public boolean match(char[] str, char[] pattern) {
      if (str == null || pattern == null) {
          return false;
      }
      int strIndex = 0;
      int patternIndex = 0;
      return matchCore(str, strIndex, pattern, patternIndex);
  }

  public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
      //有效性检验：str到尾，pattern到尾，匹配成功
      if (strIndex == str.length && patternIndex == pattern.length) {
          return true;
      }
      //pattern先到尾，匹配失败
      if (strIndex != str.length && patternIndex == pattern.length) {
          return false;
      }
      //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
      if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
          if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
              return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
                      || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
                      || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
          } else {
              return matchCore(str, strIndex, pattern, patternIndex + 2);
          }
      }
      //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
      if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
          return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
      }
      return false;
      }
  }
  
9.树的子结构的判断（26）
  代码：
  /**
  public class TreeNode {
      int val = 0;
      TreeNode left = null;
      TreeNode right = null;

      public TreeNode(int val) {
          this.val = val;

      }

  }
  */
  public class Solution {

      public boolean dfs2 (TreeNode node1, TreeNode node2) {
          if (node1 == null || node2 == null) {
              if (node2 == null) {
                  return true;
              } else {
                  return false;
              }
          }
          if (node1.val != node2.val) {
              return false;
          } else {
              return dfs2(node1.left, node2.left) && dfs2(node1.right, node2.right);
          }
      }

      public boolean dfs1 (TreeNode node1, TreeNode node2) {
          if (node1 == null || node2 == null) {
              if (node2 == null) {
                  return true;
              } else {
                  return false;
              }
          }
          if (node1.val == node2.val) {
              if(dfs2(node1, node2)) {
                  return true;
              }
          } 
          return dfs1(node1.left, node2) || dfs1(node1.right, node2);
      }


      public boolean HasSubtree(TreeNode root1,TreeNode root2) {
          if (root1 == null || root2 == null) {
              return false;
          }
          return dfs1(root1, root2);
      }
  }
  
10.复杂链表的复制（35）
  代码：
  /*
  public class RandomListNode {
      int label;
      RandomListNode next = null;
      RandomListNode random = null;

      RandomListNode(int label) {
          this.label = label;
      }
  }
  */
  public class Solution {
      public RandomListNode Clone(RandomListNode pHead)
      {
          if (pHead == null) {
              return null;
          }
          RandomListNode head1 = new RandomListNode(-1);
          head1.next = pHead;
          head1 = head1.next;
          RandomListNode head2 = new RandomListNode(-1);
          head2.next = pHead;
          head2 = head2.next;
          while (pHead != null) {
              RandomListNode next = pHead.next;
              RandomListNode copy = new RandomListNode(pHead.label);
              pHead.next = copy;
              copy.next = next;
              pHead = next;
          }
          while (head1 != null) {
              if (head1.random != null) {
                  head1.next.random = head1.random.next;
              }
              head1 = head1.next.next;
          }
          RandomListNode ans = new RandomListNode(-1);
          ans.next = head2.next;
          while (head2 != null) {
              RandomListNode next = head2.next.next;
              head2.next.next = head2.next.next == null ? null : head2.next.next.next;
              head2.next = null;
              head2 = next;
          }
          return ans.next;
      }
  }
  
11.序列化二叉树（37）
  思路：利用前序+中序或者后序+中序的缺点是节点值不能重复
  代码：
  /*
  public class TreeNode {
      int val = 0;
      TreeNode left = null;
      TreeNode right = null;

      public TreeNode(int val) {
          this.val = val;

      }

  }
  */
  public class Solution {

      private int index = 0;

      String Serialize(TreeNode root) {
          if (root == null) {
              return "#";
          } else {
              return root.val + "," + Serialize(root.left) +"," + Serialize(root.right);
          }
    }
      TreeNode Deserialize(String str) {
         String[] strs = str.split(",");
          if (index >= strs.length) {
              return null;
          }
          if (strs[index].equals("#")) {
              ++index;
              return null;
          }
          TreeNode node = new TreeNode(Integer.parseInt(strs[index++]));
          node.left = Deserialize(str);
          node.right = Deserialize(str);
          return node;
    }
  }
  
12.数据流中的中位数（41）
  思路：建立最大堆(升序排序)、最小堆(降序排序)，插入时维持最大堆大小等于最小堆大小(已经插入数目为偶数)，
  插入时维持最大堆大小-最小堆大小=1(已经插入数目为奇数)；取出时取最大堆与最小堆peek值得平均(已经插入数目为偶数)，
  取出时取最大堆的peek值(已经插入数目为奇数)
  代码：
  import java.util.*;
  public class Solution {

      private PriorityQueue<Integer> minQueue = new PriorityQueue<Integer>(
          (a, b) -> b - a
      );
      private PriorityQueue<Integer> maxQueue = new PriorityQueue<Integer>(
          (a, b) -> a - b
      );

      public void Insert(Integer num) {
          if (maxQueue.size() == 0 || num < maxQueue.peek()) {
              minQueue.offer(num);
          } else {
              maxQueue.offer(num);
          }
          while (maxQueue.size() - minQueue.size() > 1) {
              minQueue.offer(maxQueue.poll());
          }
          while (minQueue.size() - maxQueue.size() > 0) {
              maxQueue.offer(minQueue.poll());
          }
      }

      public Double GetMedian() {
          if (minQueue.size() == maxQueue.size()) {
              return (((double)minQueue.peek()) + maxQueue.peek())/2;
          } else {
              return (double)maxQueue.peek();
          }
      }


  }
  
13.连续子数组的最大和（42）
  代码：
  import java.util.*;
  public class Solution {
      public int FindGreatestSumOfSubArray(int[] array) {
          if (array == null || array.length < 1) {
              return 0;
          }
          // dp[i] = array[i], dp[i-1] <= 0
          // dp[i] = array[i] + dp[i-1], dp[i-1] > 0
          int pre = array[0];
          int cur = array[0];
          int ans = cur;
          for (int i = 1; i < array.length; ++i) {
              cur = pre <= 0 ? array[i] : pre + array[i];
              ans = Math.max(ans, cur);
              pre = cur;
          }
          return ans;
      }
  }
  
14.整数中1出现的次数（43）
  思路：
  统计某个位置上 1出现的次数。如34，1在十位上出现的次数是10次
  （10到19），1在个位上出现的次数是4次（1，11，21，31），因此34中1出现了14次。

  对于整数n，将这个整数分为三部分：当前位数字cur，更高位数字high，更低位数字low，如：对于n=21034，当位数是十位时，cur=3，high=210，low=4。
  我们从个位到最高位 依次计算每个位置出现1的次数：(做交叉积)
  在计算时，会出现三种情况
  1）当前位的数字等于0时，例如n=21034，在百位上的数字cur=0，百位上是1的情况有：00100-00199，01100-01199，……，20100-20199。一共有21*100种情况，即high*100;
  2）当前位的数字等于1时，例如n=21034，在千位上的数字cur=1，千位上是1的情况有：01000-01999，11000-11999，21000-21034。一共有2*1000+（34+1）种情况，即high*1000+(low+1)。
  3）当前位的数字大于1时，例如n=21034，在十位上的数字cur=3，十位上是1的情况有：00010-00019，……，21010-21019。一共有(210+1)*10种情况，即(high+1)*10。
  代码：
  public class Solution {
      public int NumberOf1Between1AndN_Solution(int n) {
          int cnt = 0;
          for (int i = 1; i <= n; i = i * 10) {
              int high = n / (i * 10);
              int low = n % i;
              int cur = (n/i)%10;
              if (cur == 0) {
                  cnt += high * i;
              } else if (cur == 1) {
                  cnt += high * i + low + 1;
              } else {
                  cnt += (high + 1) * i;
              }
          }
          return cnt;

      }
  }
  
15.数字序列中某一位的数字（44）
  代码：
  public int digitAtIndex(int index) {
        if(index<0)
            return -1;
        int m=1;  //m位数
        while(true) {
            int numbers=numbersOfIntegers(m);  //m位数的个数
            if(index<numbers*m)
                return getDigit(index,m); 
            index-=numbers*m;
            m++;
        }
    }
     
    /*
     * 返回m位数的总个数
     * 例如，两位数一共有90个：10~99；三位数有900个：100~999
     */
    private int numbersOfIntegers(int m) {
        if(m==1)
            return 10;
        return (int) (9*Math.pow(10, m-1));
    }
     
    /*
     * 获取数字
     */
    private int getDigit(int index, int m) {
        int number=getFirstNumber(m)+index/m;  //对应的m位数
        int indexFromRight = m-index%m;  //在数字中的位置
        for(int i=1;i<indexFromRight;i++)
            number/=10;
        return number%10;
    }
     
    /*
     * 第一个m位数
     * 例如第一个两位数是10，第一个三位数是100
     */
    private int getFirstNumber(int m) {
        if(m==1)
            return 0;
        return (int) Math.pow(10, m-1);
    }
