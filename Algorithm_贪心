1.参考
1.1.贪心总结：https://oi-wiki.org/basic/greedy/
1.2.修理牛棚问题(dp)：https://blog.csdn.net/jc514984625/article/details/53461816
1.3.工作有截止日期及价值问题(后悔问题)：https://www.cnblogs.com/Randolph68706/p/11197967.html
1.4.国王游戏？(排序问题)：http://old.orzsiyuan.com/articles/problem-NOIP-2012-King-Game/


2.
2.1.(leetcode [621] Task Scheduler)
  代码：
  class Solution {
      public int leastInterval(char[] tasks, int n) {
          int[] arrays = new int[26];
          for (char c : tasks) {
              arrays[c - 'A']++;
          }
          Arrays.sort(arrays);
          int cnt = (arrays[25] - 1) * (n + 1) + 1;
          int index = 24;
          while (index >= 0) {
              if (arrays[index] == arrays[25]) {
                  ++cnt;
                  --index;
              } else {
                  break;
              }
          }
          // 如果task.length大于cnt，说明cnt留下的空位被填满，然后多出多少个空位就
          // 填多少个，即为数组长度
          return Math.max(cnt, tasks.length);
      }
  }
  
  2.2.字符串问题
  2.2.1.把队列划分为连续的字串（leetcode [659] Split Array into Consecutive Subsequences）
    代码：
    class Solution {
      public boolean isPossible(int[] nums) {
          // 还有多少个的map
          HashMap<Integer, Integer> left = new HashMap<Integer, Integer>();
          // 以x结尾的个数统计的map
          HashMap<Integer, Integer> end = new HashMap<Integer, Integer>();
          for (int num : nums) {
              left.put(num, left.getOrDefault(num, 0) + 1);
          }
          for (int num : nums) {
              if(left.get(num) == 0) {
                  continue;
              }
              left.put(num, left.get(num) - 1);
              if (end.getOrDefault(num-1, 0) > 0) {
                  // 塞到前一个队列
                  end.put(num-1, end.get(num-1)-1);
                  end.put(num, end.getOrDefault(num, 0)+1);
              } else if (left.getOrDefault(num+1, 0) > 0 && left.getOrDefault(num+2, 0) > 0) {
                  // 建新的队列
                  left.put(num+1, left.get(num+1)-1);
                  left.put(num+2, left.get(num+2)-1);
                  end.put(num+2, end.getOrDefault(num+2, 0)+1);
              } else {
                  return false;
              }
          }
          return true;
      }
  }
2.2.2.判断一个字符串是否是另一个字符串的子串（leetcode [392] Is Subsequence）
  思路：贪心+二分搜索
  代码：
  class Solution {
      public boolean isSubsequence(String s, String t) {
          if (s == null || t == null) {
              return false;
          }
          if (s.length() == 0) {
              return true;
          }
          /*
          int i = 0, j = 0;
          for (; i < t.length() && j < s.length(); ++i) {
              if (s.charAt(j) == t.charAt(i)) {
                  ++j;
              }
          }
          return j == s.length();
          */
          List<Integer> lists[] = new ArrayList[26];
          for (int i = 0; i < 26; ++i) {
              lists[i] = new ArrayList<Integer>();
          }
          for (int i = 0; i < t.length(); ++i) {
              char c  = t.charAt(i);
              lists[c - 'a'].add(i);
          }
          int pre  = -1;
          for (int i = 0; i < s.length(); ++i) {
              int c = s.charAt(i) - 'a';
              int left = 0;
              int right = lists[c].size() - 1;
              while (left < right) {
                  int mid = left + (right - left)/2;
                  if (lists[c].get(mid) > pre) {
                      right = mid;
                  } else {
                      left = mid + 1;
                  }
              }
              if (right < left || lists[c].get(left) <= pre) {
                  return false;
              }
              pre = lists[c].get(left);
          }
          return true;
      }
  }

  
2.3.会议最晚开始（leetcode 1353. Maximum Number of Events That Can Be Attended）
  代码：
  class Solution {
      public int maxEvents(int[][] events) {
          Arrays.sort(
              events,
              (a, b) -> a[1] - b[1]
          );
          HashSet<Integer> set = new HashSet<>();
          for (int[] event : events) {
              int start = event[0];
              int end = event[1];
              for (int i = start; i <= end; ++i) {
                  if (!set.contains(i)) {
                      set.add(i);
                      break;
                  }
              }
          }
          return set.size();
      }
  }
 
 2.4.分割字符串得到平衡子串（leetcode [1221] Split a String in Balanced Strings）
  代码：
  class Solution {
      public int balancedStringSplit(String s) {
          int left = 0;
          int right = 0;
          int ans = 0;
          for (char c : s.toCharArray()) {
              if (c == 'L') {
                  ++left;
              }
              if (c == 'R') {
                  ++right;
              }
              if (left > 0 && left == right) {
                  ++ans;
                  left = 0;
                  right = 0;
              }
          }
          return ans;
      }
  }
  
  2.5.贪心之排序问题
  2.5.1.飞机飞往两个地方的选择调度的最小费用问题（leetcode [1029] Two City Scheduling）
    代码：
    class Solution {
      public int twoCitySchedCost(int[][] costs) {
          // 所有人(2N)都先飞往a城市，然后从中选出N个人飞往b城市
          // 飞往a城市总费用每个人去a的和，选出的人飞往b城市的费用为b[i]-a[i]
          // 飞往a的总费用是个常数，所以要使得选出的飞往b城市的n个人的费用最小
          Arrays.sort(
              costs,
              (a, b) -> (a[1] - a[0]) - (b[1] - b[0])
          );
          int ans = 0;
          for (int i = 0; i < costs.length; ++i) {
              if (i < costs.length/2) {
                  ans += costs[i][1];
              } else {
                  ans += costs[i][0];
              }
          }
          return ans;
      }
  }
2.5.2.事先排序解决需求满足问题（leetcode [455] Assign Cookies）
  相关：阿里2020.04.01笔试第二题
  代码：
  class Solution {
      public int findContentChildren(int[] g, int[] s) {
          if (g == null || g.length < 1 || s == null || s.length < 1){
              return 0;
          }
          int m = g.length;
          int n = s.length;
          int i = 0; 
          int j = 0;
          Arrays.sort(g);
          Arrays.sort(s);
          for (; i < m; ) {
              if (j < n) {
                  if (g[i] <= s[j]) {
                      ++i;
                      ++j;
                  } else {
                      ++j;
                  }
              } else {
                  break;
              }
          }
          return i;
      }
  }

