1.参考
1.1.贪心总结：https://oi-wiki.org/basic/greedy/
1.2.修理牛棚问题(dp)：https://blog.csdn.net/jc514984625/article/details/53461816
1.3.工作有截止日期及价值问题(后悔问题)：https://www.cnblogs.com/Randolph68706/p/11197967.html
1.4.国王游戏？(排序问题)：http://old.orzsiyuan.com/articles/problem-NOIP-2012-King-Game/


2.
2.1.(leetcode [621] Task Scheduler)
  代码：
  class Solution {
      public int leastInterval(char[] tasks, int n) {
          int[] arrays = new int[26];
          for (char c : tasks) {
              arrays[c - 'A']++;
          }
          Arrays.sort(arrays);
          int cnt = (arrays[25] - 1) * (n + 1) + 1;
          int index = 24;
          while (index >= 0) {
              if (arrays[index] == arrays[25]) {
                  ++cnt;
                  --index;
              } else {
                  break;
              }
          }
          // 如果task.length大于cnt，说明cnt留下的空位被填满，然后多出多少个空位就
          // 填多少个，即为数组长度
          return Math.max(cnt, tasks.length);
      }
  }
  
  2.2.字符串问题
  2.2.1.把队列划分为连续的字串（leetcode [659] Split Array into Consecutive Subsequences）
    代码：
    class Solution {
      public boolean isPossible(int[] nums) {
          // 还有多少个的map
          HashMap<Integer, Integer> left = new HashMap<Integer, Integer>();
          // 以x结尾的个数统计的map
          HashMap<Integer, Integer> end = new HashMap<Integer, Integer>();
          for (int num : nums) {
              left.put(num, left.getOrDefault(num, 0) + 1);
          }
          for (int num : nums) {
              if(left.get(num) == 0) {
                  continue;
              }
              left.put(num, left.get(num) - 1);
              if (end.getOrDefault(num-1, 0) > 0) {
                  // 塞到前一个队列
                  end.put(num-1, end.get(num-1)-1);
                  end.put(num, end.getOrDefault(num, 0)+1);
              } else if (left.getOrDefault(num+1, 0) > 0 && left.getOrDefault(num+2, 0) > 0) {
                  // 建新的队列
                  left.put(num+1, left.get(num+1)-1);
                  left.put(num+2, left.get(num+2)-1);
                  end.put(num+2, end.getOrDefault(num+2, 0)+1);
              } else {
                  return false;
              }
          }
          return true;
      }
  }
2.2.2.判断一个字符串是否是另一个字符串的子串（leetcode [392] Is Subsequence）
  思路：贪心+二分搜索
  代码：
  class Solution {
      public boolean isSubsequence(String s, String t) {
          if (s == null || t == null) {
              return false;
          }
          if (s.length() == 0) {
              return true;
          }
          /*
          int i = 0, j = 0;
          for (; i < t.length() && j < s.length(); ++i) {
              if (s.charAt(j) == t.charAt(i)) {
                  ++j;
              }
          }
          return j == s.length();
          */
          List<Integer> lists[] = new ArrayList[26];
          for (int i = 0; i < 26; ++i) {
              lists[i] = new ArrayList<Integer>();
          }
          for (int i = 0; i < t.length(); ++i) {
              char c  = t.charAt(i);
              lists[c - 'a'].add(i);
          }
          int pre  = -1;
          for (int i = 0; i < s.length(); ++i) {
              int c = s.charAt(i) - 'a';
              int left = 0;
              int right = lists[c].size() - 1;
              while (left < right) {
                  int mid = left + (right - left)/2;
                  if (lists[c].get(mid) > pre) {
                      right = mid;
                  } else {
                      left = mid + 1;
                  }
              }
              if (right < left || lists[c].get(left) <= pre) {
                  return false;
              }
              pre = lists[c].get(left);
          }
          return true;
      }
  }
2.2.3.字母区间问题（leetcode [763] Partition Labels）
  代码：
  class Solution {

      public class Point {
          int first;
          int last;

          public void setFirst(int x) {
              first = x;
          }

          public void setLast(int y) {
              last = y;
          }
      }

      public List<Integer> partitionLabels(String S) {
          char[] indexs = new char[27];
          HashMap<Character, Point> map = new HashMap<>();
          int cnt = 0;
          for (int i = 0; i < S.length(); ++i) {
              char temp = S.charAt(i);
              if (!map.containsKey(temp)) {
                  indexs[cnt++] = temp;
                  map.put(temp, new Point());
                  map.get(temp).setFirst(i);
                  map.get(temp).setLast(i);
              } else {
                  map.get(temp).setLast(i);
              }
          }
          List<Integer> ans = new ArrayList<>();
          int first1 = map.get(indexs[0]).first;
          int last1 = map.get(indexs[0]).last;
          for (int i = 1; i < cnt; ++i) {
              int first2 = map.get(indexs[i]).first;
              int last2 = map.get(indexs[i]).last;
              if (last1 < first2) {
                  ans.add(last1 - first1 + 1);
                  first1 = first2;
                  last1 = last2;
              } else if (last2 > last1) {
                  last1 = last2;
              }
          }
          ans.add(last1-first1+1);
          return ans;
      }
  }
2.2.4.分割字符串得到平衡子串（leetcode [1221] Split a String in Balanced Strings）
  代码：
  class Solution {
      public int balancedStringSplit(String s) {
          int left = 0;
          int right = 0;
          int ans = 0;
          for (char c : s.toCharArray()) {
              if (c == 'L') {
                  ++left;
              }
              if (c == 'R') {
                  ++right;
              }
              if (left > 0 && left == right) {
                  ++ans;
                  left = 0;
                  right = 0;
              }
          }
          return ans;
      }
  }
  
2.3.会议最晚开始（leetcode 1353. Maximum Number of Events That Can Be Attended）
  代码：
  class Solution {
      public int maxEvents(int[][] events) {
          Arrays.sort(
              events,
              (a, b) -> a[1] - b[1]
          );
          HashSet<Integer> set = new HashSet<>();
          for (int[] event : events) {
              int start = event[0];
              int end = event[1];
              for (int i = start; i <= end; ++i) {
                  if (!set.contains(i)) {
                      set.add(i);
                      break;
                  }
              }
          }
          return set.size();
      }
  }
 
 
  
  2.5.贪心之排序问题
  2.5.1.飞机飞往两个地方的选择调度的最小费用问题（leetcode [1029] Two City Scheduling）
    代码：
    class Solution {
      public int twoCitySchedCost(int[][] costs) {
          // 所有人(2N)都先飞往a城市，然后从中选出N个人飞往b城市
          // 飞往a城市总费用每个人去a的和，选出的人飞往b城市的费用为b[i]-a[i]
          // 飞往a的总费用是个常数，所以要使得选出的飞往b城市的n个人的费用最小
          Arrays.sort(
              costs,
              (a, b) -> (a[1] - a[0]) - (b[1] - b[0])
          );
          int ans = 0;
          for (int i = 0; i < costs.length; ++i) {
              if (i < costs.length/2) {
                  ans += costs[i][1];
              } else {
                  ans += costs[i][0];
              }
          }
          return ans;
      }
  }
2.5.2.事先排序解决需求满足问题（leetcode [455] Assign Cookies）
  相关：阿里2020.04.01笔试第二题
  代码：
  class Solution {
      public int findContentChildren(int[] g, int[] s) {
          if (g == null || g.length < 1 || s == null || s.length < 1){
              return 0;
          }
          int m = g.length;
          int n = s.length;
          int i = 0; 
          int j = 0;
          Arrays.sort(g);
          Arrays.sort(s);
          for (; i < m; ) {
              if (j < n) {
                  if (g[i] <= s[j]) {
                      ++i;
                      ++j;
                  } else {
                      ++j;
                  }
              } else {
                  break;
              }
          }
          return i;
      }
  }

2.6.矩阵问题
2.6.1.存在障碍和旋转的机器人移动问题（leetcode [874] Walking Robot Simulation）
  代码：
  class Solution {

      public static final int val = 70010;

      public int robotSim(int[] commands, int[][] obstacles) {
          int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
          int x = 0;
          int y = 0;
          int dir = 0;
          HashSet<Integer> set = new HashSet<>();
          for (int[] obstacle : obstacles) {
              set.add((obstacle[0] + 30000)*val + obstacle[1] + 30000);
          }
          // 涉及到正负数范围二维数据压缩为一维数据
          // 设计单位坐标系通过取模来实现左转右转
          int ans = 0;
          for (int command : commands) {
              if (command == -1) {
                  dir = (dir + 1) % 4;
              } else if (command == -2) {
                  dir = (dir + 3) % 4;
              } else {
                  for (int cnt = 1; cnt <= command; ++cnt) {                    
                      int nextX = x + directions[dir][0];
                      int nextY = y + directions[dir][1];
                      if (set.contains((nextX + 30000)*val + nextY + 30000)) {    
                          ans = Math.max(ans, x*x + y*y);                    
                          break;
                      } else {
                          x = nextX;
                          y = nextY;
                          ans = Math.max(ans, x*x + y*y);
                      }
                  }
              }
          }
          return ans;
      }
  }
2.6.2.成行成列矩阵翻转问题求得最大得分问题（leetcode [861] Score After Flipping Matrix）
  代码：
  class Solution {

      int[][] matrix;
      int m;
      int n;

      public void rowChange(int i) {
          for (int j = 0; j < n; ++j) {
              matrix[i][j] = 1 - matrix[i][j];
          }
      }

      public void colChange(int j) {
          for (int i = 0; i < m; ++i) {
              matrix[i][j] = 1 - matrix[i][j];
          }
      }

      public int matrixScore(int[][] A) {
          matrix = A;
          m = A.length;
          n = A[0].length;
          for (int i = 0; i < m; ++i) {
              if (matrix[i][0] != 1) {
                  rowChange(i);
              }
          }
          int ans = 0;
          ans += m * Math.pow(2, n-1);
          for (int j = 1; j < n; ++j) {
              int cnt1 = 0;
              for (int i = 0; i < m; ++i) {
                  cnt1 += matrix[i][j];
              }
              cnt1 = Math.max(cnt1, m-cnt1);
              ans += cnt1 * Math.pow(2, n-1-j);
          }
          return ans;
      }
  }
