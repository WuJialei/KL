1.堆的概念
堆是一种特殊类型的二叉树，具有以下两个性质：
  每个节点的值大于等于(或小于等于)其每个子节点的值
  堆属于完全二叉树

2.基本知识参考
2.1.https://juejin.im/post/5c3067866fb9a04a0a5f5578
2.2.https://dracarys.github.io/2019/03/02/Algorithm-club-heap/

3.优先级队列
优先级队列介绍：https://www.cnblogs.com/gnivor/p/4841191.html
3.1.石头撞击消除（leetcode [1046] Last Stone Weight）
  代码：
  class Solution {
      public int lastStoneWeight(int[] stones) {
          PriorityQueue<Integer> queue = new PriorityQueue<Integer>(
              new Comparator<Integer>() {
                  @Override
                  public int compare(Integer a, Integer b) {
                      return b - a;
                  }
              }
          );
          for (int stone : stones) {
              queue.offer(stone);
          }
          while (queue.size() > 1) {
              int a = queue.poll();
              int b = queue.poll();
              if (a > b) {
                  queue.offer(a-b);
              }
          }
          if (queue.isEmpty()) {
              return 0;
          } else {
              return queue.peek();
          }
      }
  }
3.2.求第k大元素（不是第k个不同）（leetcode [703] Kth Largest Element in a Stream）
  思路：构建固定容量的优先级队列，最大堆
  代码：
  class KthLargest {

      PriorityQueue<Integer> queue;
      int k;

      public KthLargest(int k, int[] nums) {
          this.k = k;
          queue = new PriorityQueue<Integer>(
              k,
              new Comparator<Integer>() {
                  @Override
                  public int compare(Integer a, Integer b) {
                      return a - b;
                  }
              }
          );
          for (int num : nums) {
              add(num);
          }
      }

      public int add(int val) {
          // 判断优先级队列是否需要调整，即固定容量的逆序最大堆是否发生变化
          if (queue.size() < k) {
              queue.offer(val);
          } else if (val > queue.peek()) {
              queue.poll();
              queue.offer(val);
          }
          return queue.peek();
      }
  }
  变体1，求出现频率在top k的数组(链表)(leetcode [347] Top K Frequent Elements)
    代码：
    class Solution {

      HashMap<Integer, Integer> map;

      public List<Integer> topKFrequent(int[] nums, int k) {
          map = new HashMap<Integer, Integer>();
          for (int num : nums) {
              map.put(num, map.getOrDefault(num, 0) + 1);
          }

          PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k,
              new Comparator<Integer>() {
                  @Override
                  public int compare(Integer a, Integer b){
                      return map.get(a) - map.get(b);
                  }
              }
          );
          for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
              if (queue.size() < k) {
                  queue.offer(entry.getKey());
              } else if (entry.getValue() > map.get(queue.peek())) {
                  queue.poll();
                  queue.offer(entry.getKey());
              }
          }
          List<Integer> ans = new ArrayList<Integer>();
          while(!queue.isEmpty()) {
              ans.add(queue.poll());
          }       
          return ans;

      }
  }
  变体2，求离原点最近的top k个点(leetcode [973] K Closest Points to Origin)
    代码：
    class Solution {

    public int squre (int a, int b) {
        return a * a + b * b;
    }

    public int[][] kClosest(int[][] points, int K) {
        PriorityQueue<int[]> queue = new PriorityQueue<>(K, (o2, o1) -> o1[0] * o1[0] + o1[1] * o1[1] - o2[0] * o2[0] - o2[1] * o2[1]);

        for (int i = 0; i < points.length; ++i) {
            if (queue.size() < K) {
                queue.offer(points[i]);
            } else if (squre(points[i][0], points[i][1]) < squre(queue.peek()[0], queue.peek()[1])) {
                queue.poll();
                queue.offer(points[i]);
            }
        }
        int[][] ans = new int[K][2];
        int cnt = 0;
        while(!queue.isEmpty()) {
            ans[cnt] = queue.poll();
            ++cnt;
        }
        return ans;
    }
}
相关：HashMap的排序（leetcode [451] Sort Characters By Frequency）
  代码：
  class Solution {
      public String frequencySort(String s) {
          HashMap<Character, Integer> map = new HashMap<>();
          for (char c : s.toCharArray()) {
              map.put(c, map.getOrDefault(c, 0) + 1);
          }
          List<Map.Entry<Character, Integer>> list = new ArrayList<>(map.entrySet());
          Collections.sort(list, (a, b) -> b.getValue() - a.getValue());
          StringBuilder ans = new StringBuilder();
          for (Map.Entry<Character, Integer> t : list) {
              int cnt = t.getValue();
              while (cnt > 0) {
                  ans.append(t.getKey());
                  --cnt;
              }
          }
          return ans.toString();
      }
  }
备注：Arrays.sort()支持Integer [] 而不支持 int []（leetcode [215] Kth Largest Element in an Array）
  代码：
  class Solution {
      public int findKthLargest(int[] nums, int k) {
          Integer nums1[] = new Integer[nums.length];
          for (int i = 0 ; i < nums.length ; i ++) nums1[i] = nums[i];
          // Arrays.sort()支持Integer [] 而不支持 int []
          Arrays.sort(nums1, (a, b) -> b-a);
          return nums1[k-1];
      }
  }

