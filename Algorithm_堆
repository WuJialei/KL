1.堆的概念
堆是一种特殊类型的二叉树，具有以下两个性质：
  每个节点的值大于等于(或小于等于)其每个子节点的值
  堆属于完全二叉树

2.基本知识参考
2.1.https://juejin.im/post/5c3067866fb9a04a0a5f5578
2.2.https://dracarys.github.io/2019/03/02/Algorithm-club-heap/

3.优先级队列
优先级队列介绍：https://www.cnblogs.com/gnivor/p/4841191.html
3.1.石头撞击消除（leetcode [1046] Last Stone Weight）
  代码：
  class Solution {
      public int lastStoneWeight(int[] stones) {
          PriorityQueue<Integer> queue = new PriorityQueue<Integer>(
              new Comparator<Integer>() {
                  @Override
                  public int compare(Integer a, Integer b) {
                      return b - a;
                  }
              }
          );
          for (int stone : stones) {
              queue.offer(stone);
          }
          while (queue.size() > 1) {
              int a = queue.poll();
              int b = queue.poll();
              if (a > b) {
                  queue.offer(a-b);
              }
          }
          if (queue.isEmpty()) {
              return 0;
          } else {
              return queue.peek();
          }
      }
  }
3.2.求第k大元素（不是第k个不同）（leetcode [703] Kth Largest Element in a Stream）
  思路：构建固定容量的优先级队列，最大堆
  代码：
  class KthLargest {

      PriorityQueue<Integer> queue;
      int k;

      public KthLargest(int k, int[] nums) {
          this.k = k;
          queue = new PriorityQueue<Integer>(
              k,
              new Comparator<Integer>() {
                  @Override
                  public int compare(Integer a, Integer b) {
                      return a - b;
                  }
              }
          );
          for (int num : nums) {
              add(num);
          }
      }

      public int add(int val) {
          // 判断优先级队列是否需要调整，即固定容量的逆序最大堆是否发生变化
          if (queue.size() < k) {
              queue.offer(val);
          } else if (val > queue.peek()) {
              queue.poll();
              queue.offer(val);
          }
          return queue.peek();
      }
  }
  变体，求出现频率在top k的数组(链表)(leetcode [347] Top K Frequent Elements)
    代码：
    class Solution {

      HashMap<Integer, Integer> map;

      public List<Integer> topKFrequent(int[] nums, int k) {
          map = new HashMap<Integer, Integer>();
          for (int num : nums) {
              map.put(num, map.getOrDefault(num, 0) + 1);
          }

          PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k,
              new Comparator<Integer>() {
                  @Override
                  public int compare(Integer a, Integer b){
                      return map.get(a) - map.get(b);
                  }
              }
          );
          for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
              if (queue.size() < k) {
                  queue.offer(entry.getKey());
              } else if (entry.getValue() > map.get(queue.peek())) {
                  queue.poll();
                  queue.offer(entry.getKey());
              }
          }
          List<Integer> ans = new ArrayList<Integer>();
          while(!queue.isEmpty()) {
              ans.add(queue.poll());
          }       
          return ans;

      }
  }

