1.二分
1.1.二分模板讲解：https://www.liwei.party/2019/06/18/leetcode-solution-new/search-insert-position/
  l < r保证返回时l=r;
  mid = l + (r-l)/2保证r+l不溢出，r-l在l为负数且r为很大正数的时候也会溢出，但一般l，r为索引不会有这种情况
1.2.二分模板（以leetcode 35为例）
  代码：
  public class Solution {

      public int searchInsert(int[] nums, int target) {
          int len = nums.length;
          if (len == 0) {
              return 0;
          }
          if (target > nums[len - 1]) {
              return len;
          }
          int left = 0;
          int right = len - 1;
          while (left < right) {
              int mid = left + (right - left) / 2;
              if (nums[mid] < target) {
                  left = mid + 1;
              } else {
                  right = mid;
              }
          }
          return right;
      }
  }



3.1.有序矩阵中的第k小元素（leetcode [378] Kth Smallest Element in a Sorted Matrix）
  代码：
  class Solution {
      public int kthSmallest(int[][] matrix, int k) {
          int len = matrix.length;
          int left = matrix[0][0];
          int right = matrix[len-1][len-1];
          while (left < right) {
              int mid = left + (right - left)/2;
              int cnt = 0;
              for (int i = 0; i < len; ++i) {
                  for (int j = 0; j < len && matrix[i][j] <= mid; ++j) {
                      ++cnt;
                  }
              }
              if (cnt >= k) {
                  right = mid;
              } else {
                  left = mid + 1;
              }
          }
          return left;
      }
  }
  
大规模的字符串检查是否是模板的子序列（leetcode [392] Is Subsequence）
  代码：
  class Solution {
      public boolean isSubsequence(String s, String t) {
          if (s == null || t == null) {
              return false;
          }
          if (s.length() == 0) {
              return true;
          }
          /*
          int i = 0, j = 0;
          for (; i < t.length() && j < s.length(); ++i) {
              if (s.charAt(j) == t.charAt(i)) {
                  ++j;
              }
          }
          return j == s.length();
          */
          List<Integer> lists[] = new ArrayList[26];
          for (int i = 0; i < 26; ++i) {
              lists[i] = new ArrayList<Integer>();
          }
          for (int i = 0; i < t.length(); ++i) {
              char c  = t.charAt(i);
              lists[c - 'a'].add(i);
          }
          int pre  = -1;
          for (int i = 0; i < s.length(); ++i) {
              int c = s.charAt(i) - 'a';
              int left = 0;
              int right = lists[c].size() - 1;
              while (left < right) {
                  int mid = left + (right - left)/2;
                  if (lists[c].get(mid) > pre) {
                      right = mid;
                  } else {
                      left = mid + 1;
                  }
              }
              if (right < left || lists[c].get(left) <= pre) {
                  return false;
              }
              pre = lists[c].get(left);
          }
          return true;
      }
  }

