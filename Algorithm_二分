




3.1.有序矩阵中的第k小元素（leetcode [378] Kth Smallest Element in a Sorted Matrix）
  代码：
  class Solution {
      public int kthSmallest(int[][] matrix, int k) {
          int len = matrix.length;
          int left = matrix[0][0];
          int right = matrix[len-1][len-1];
          while (left < right) {
              int mid = left + (right - left)/2;
              int cnt = 0;
              for (int i = 0; i < len; ++i) {
                  for (int j = 0; j < len && matrix[i][j] <= mid; ++j) {
                      ++cnt;
                  }
              }
              if (cnt >= k) {
                  right = mid;
              } else {
                  left = mid + 1;
              }
          }
          return left;
      }
  }
  
大规模的字符串检查是否是模板的子序列（leetcode [392] Is Subsequence）
  代码：
  class Solution {
      public boolean isSubsequence(String s, String t) {
          if (s == null || t == null) {
              return false;
          }
          if (s.length() == 0) {
              return true;
          }
          /*
          int i = 0, j = 0;
          for (; i < t.length() && j < s.length(); ++i) {
              if (s.charAt(j) == t.charAt(i)) {
                  ++j;
              }
          }
          return j == s.length();
          */
          List<Integer> lists[] = new ArrayList[26];
          for (int i = 0; i < 26; ++i) {
              lists[i] = new ArrayList<Integer>();
          }
          for (int i = 0; i < t.length(); ++i) {
              char c  = t.charAt(i);
              lists[c - 'a'].add(i);
          }
          int pre  = -1;
          for (int i = 0; i < s.length(); ++i) {
              int c = s.charAt(i) - 'a';
              int left = 0;
              int right = lists[c].size() - 1;
              while (left < right) {
                  int mid = left + (right - left)/2;
                  if (lists[c].get(mid) > pre) {
                      right = mid;
                  } else {
                      left = mid + 1;
                  }
              }
              if (right < left || lists[c].get(left) <= pre) {
                  return false;
              }
              pre = lists[c].get(left);
          }
          return true;
      }
  }

