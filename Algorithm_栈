1.参考
1.1.http://fanqieto.top/2018/09/04/LeetCode-%E6%A0%88%E7%B1%BB%E7%AE%97%E6%B3%95%E7%B2%BE%E6%9E%90/
1.2.https://blog.csdn.net/koudaidai/article/details/7571521
1.3.https://my.oschina.net/brianway/blog/1545142

2.实际问题
2.1.括号类
2.1.1.删除最外层的括号(leetcode [1021] Remove Outermost Parentheses)
  关键：判断栈是否为空找到最外层的括号位置；动态记录最外层括号包裹的子字符串
  代码：
  class Solution {
      public String removeOuterParentheses(String S) {
          StringBuilder ans = new StringBuilder("");
          Stack<Character> stack = new Stack<Character>();
          int start = 0;
          boolean flag = false;
          for (int i = 0; i < S.length(); ++i) {
              if (S.charAt(i) == '(') {
                  stack.push('(');
                  if (!flag) {
                      start = i;
                      flag = true;
                  } 
              } else {
                  char c = stack.pop();
                  if (stack.isEmpty()) {
                      ans.append(S.substring(start+1, i));
                      flag = false;
                  }
              }
          }
          return ans.toString();
      }
  }
2.1.2.括号匹配（leetcode [1249] Minimum Remove to Make Valid Parentheses）
  代码：
  class Solution {
      public String minRemoveToMakeValid(String s) {
          Stack<Integer> stack = new Stack<Integer>();
          for (int i = 0; i < s.length(); ++i) {
              if (s.charAt(i) == '(') {
                  stack.push(i);
              } else if (s.charAt(i) == ')'){
                  if (!stack.isEmpty() && s.charAt(stack.peek()) == '(') {
                      stack.pop();
                  } else {
                      stack.push(i);
                  }
              }
          }
          String ans = new String("");
          int end = s.length();
          while (!stack.isEmpty()) {
              int start = stack.pop();
              ans = s.substring(start+1, end) + ans;
              end = start;
          }
          ans = s.substring(0, end) + ans;
          return ans;
      }
  }
2.1.3.括号的分数（leetcode [856] Score of Parentheses）
  代码：
  class Solution {
      public int scoreOfParentheses(String S) {
          Stack<Integer> stack = new Stack<Integer>();
          stack.push(0);
          for (char c : S.toCharArray()) {
              if (c == '(') {
                  // 深度加1， 得分为0
                  stack.push(0);
              } else {
                  // 当前得分加倍，并将该得分加到上一层深度
                  int cur = stack.pop();
                  int last = stack.pop();
                  stack.push(last + Math.max(1, 2 * cur));
              }
          }
          return stack.pop();
      }
  }
2.1.4.反转每对括号内的子串（leetcode [1190] Reverse Substrings Between Each Pair of Parentheses）
  代码：
  class Solution {
      int[] location;
      public String reverseParentheses(String s) {
          StringBuilder ans = new StringBuilder("");
          location = new int[s.length()];
          Stack<Integer> stack = new Stack<Integer>();
          for (int i = 0; i < s.length(); ++i) {
              if (s.charAt(i) == '(') {
                  stack.push(i);
              } else if (s.charAt(i) == ')') {
                  int pre = stack.pop();
                  location[pre] = i;
                  location[i] = pre;
              }
          }
          reverse(s, false, 0, s.length()-1, ans);
          return ans.toString();
      }

      public void reverse(String s, boolean flag, int start, int end, StringBuilder sb) {
          if (flag) {
              for (int i = end; i >= start; --i) {
                  if (s.charAt(i) == ')') {
                      reverse(s, false, location[i]+1, i-1, sb);
                      i = location[i];
                  } else {
                      sb.append(s.charAt(i));
                  }
              }
          } else {
              for (int i = start; i <= end; ++i) {
                  if (s.charAt(i) == '(') {
                      reverse(s, true, i+1, location[i]-1, sb);
                      i = location[i];
                  } else {
                      sb.append(s.charAt(i));
                  }
              }

          }
      }

  }
  
2.2.单调栈
参考：https://blog.csdn.net/qq_17550379/article/details/86519771
2.2.1.寻找一个数组每个元素在它右边出现的第一个大于它的数(leetcode [496] Next Greater Element I)
  变型：leetcode:[739] Daily Temperatures;
  代码：
  class Solution {
      public int[] nextGreaterElement(int[] nums1, int[] nums2) {
          HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
          Stack<Integer> stack = new Stack<Integer> ();
          int[] ans = new int[nums1.length];
          for (int num : nums2) {
              if (stack.isEmpty()) {
                  stack.push(num);
              } else {
                  // 单调栈是严格单调递减的
                  while (!stack.isEmpty() && stack.peek() < num) {
                      map.put(stack.pop(), num);
                  }
                  stack.push(num);
              }
          }
          while (!stack.isEmpty()) {
              map.put(stack.pop(), -1);
          }
          for (int i = 0; i < nums1.length; ++i) {
              ans[i] = map.get(nums1[i]);
          }
          return ans;
      }
  }
 2.2.2.循环寻找一个数组每个元素在它右边出现的第一个大于它的数（leetcode 503. Next Greater Element II）
    代码：
    class Solution {
        public int[] nextGreaterElements(int[] nums) {
            int[] ans = new int[nums.length];
            boolean[] flag = new boolean[nums.length];
            Stack<Integer> stack = new Stack<Integer>();
            for (int i = 0; i < nums.length; ++i) {
                if (i == 0) {
                    stack.push(0);
                } else {
                    while(!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
                        int t = stack.pop();
                        ans[t] = nums[i];
                        flag[t] = true;
                    }
                    stack.push(i);
                }
            }
            for (int i = 0; i < nums.length; ++i) {
                if (stack.isEmpty()) {
                    break;
                } else {
                    while(!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
                        int t = stack.pop();
                        ans[t] = nums[i];
                        flag[t] = true;
                    }
                    if (!flag[i]) {
                        stack.push(i);
                    }                
                }
            }
            for (int i = 0; i < nums.length; ++i) {
                if (!flag[i]) {
                    ans[i] = -1;
                }
            }
            return ans;
        }
    }
2.2.3.叶值的最小代价生成树(leetcode [1130] Minimum Cost Tree From Leaf Values)
  代码：
  class Solution {
      public int mctFromLeafValues(int[] arr) {
          Stack<Integer> stack = new Stack<Integer>();
          stack.push(Integer.MAX_VALUE);
          int res = 0;
          for (int num : arr) {
              // 对于出现在小于它的数，都要将该数去除，即为寻找该数左右最小的数
              while (num >= stack.peek()) {
                  int little = stack.pop();
                  res += little * Math.min(num, stack.peek());
              }
              stack.push(num);
          }
          while (stack.size() > 2) {
              int top = stack.pop();
              res += top * stack.peek();
          }
          return res;
      }
  }
  
2.3.栈和队列的相互转换
2.3.1.双栈实现队列(leetcode [232] Implement Queue using Stacks)
    代码：
    class MyQueue {

        Stack<Integer> stack1 = new Stack<Integer>();
        Stack<Integer> stack2 = new Stack<Integer>();

        /** Initialize your data structure here. */
        public MyQueue() {

        }

        /** Push element x to the back of queue. */
        public void push(int x) {
            stack1.push(x);
        }

        /** Removes the element from in front of queue and returns that element. */
        public int pop() {
            if (stack2.isEmpty()) {
                while (!stack1.isEmpty()) {
                    stack2.push(stack1.pop());
                }
            } 
            return stack2.pop();
        }

        /** Get the front element. */
        public int peek() {
            if (stack2.isEmpty()) {
                while (!stack1.isEmpty()) {
                    stack2.push(stack1.pop());
                }
            } 
            return stack2.peek();
        }

        /** Returns whether the queue is empty. */
        public boolean empty() {
            return stack1.isEmpty() && stack2.isEmpty();
        }
    }
2.3.2.双队列实现栈（leetcode [225] Implement Stack using Queues）
      思路：留住最后一个元素
      代码：
      class MyStack {

          Queue<Integer> queue1 = new LinkedList<Integer>();
          Queue<Integer> queue2 = new LinkedList<Integer>();

          /** Initialize your data structure here. */
          public MyStack() {

          }

          /** Push element x onto stack. */
          public void push(int x) {
              queue1.offer(x);
          }

          /** Removes the element on top of the stack and returns that element. */
          public int pop() {
              while (queue1.size() > 1) {
                  queue2.offer(queue1.poll());
              }
              int ans = queue1.poll();
              Queue<Integer> temp = queue1;
              queue1 = queue2;
              queue2 = temp;
              return ans;
          }

          /** Get the top element. */
          public int top() {
              while (queue1.size() > 1) {
                  queue2.offer(queue1.poll());
              }
              int ans = queue1.poll();
              queue2.offer(ans);
              Queue<Integer> temp = queue1;
              queue1 = queue2;
              queue2 = temp;
              return ans;
          }

          /** Returns whether the stack is empty. */
          public boolean empty() {
              return queue1.isEmpty();
          }
      }
      
2.4.最小栈
2.4.1.实现最小栈（leetcode [155] Min Stack）
  思路：使用辅助栈（非严格单调，如果数据栈和辅助栈同步空间会大一些）
  代码：
  class MinStack {

      Stack<Integer> stack = new Stack<Integer>();
      Stack<Integer> minStack = new Stack<Integer>();

      /** initialize your data structure here. */
      public MinStack() {

      }

      public void push(int x) {
          stack.push(x);
          if (minStack.isEmpty()) {
              minStack.push(x);
          } else {
              if (minStack.peek() >= x) {
                  minStack.push(x);
              }
          }
      }

      public void pop() {
          if (stack.isEmpty()) {
              return;
          }
          int top = stack.pop();
          if (!minStack.isEmpty() && minStack.peek() == top) {
              minStack.pop();
          }
      }

      public int top() {
          return stack.peek();
      }

      public int getMin() {
          return minStack.peek();
      }
  }
  
  2.5.二叉树的遍历
  2.5.1.使用辅助栈实现二叉树非递归中序遍历（leetcode [94] Binary Tree Inorder Traversal）
    代码：
    class Solution {

        List<Integer> ans = new ArrayList<Integer>();
        public List<Integer> inorderTraversal(TreeNode root) {
            /*
            dfs(root);
            return ans;
            */
            Stack<TreeNode> stack = new Stack<TreeNode>();
            List<Integer> ret = new ArrayList<Integer>();
            TreeNode node = root;
            while (node != null || !stack.isEmpty()) {
                while (node != null) {
                    stack.push(node);
                    node = node.left;
                }
                TreeNode n = stack.pop();
                ret.add(n.val);
                node = n.right;
            }
            return ret;
        }

        public void dfs(TreeNode node) {
            if (node == null) {
                return;
            }
            dfs(node.left);
            ans.add(node.val);
            dfs(node.right);
        }

    }
2.5.2.使用辅助栈根据bfs实现非递归的二叉树前序遍历（leetcode [144] Binary Tree Preorder Traversal）
  代码：
  class Solution {

      List<Integer> ans = new ArrayList<Integer>();
      public List<Integer> preorderTraversal(TreeNode root) {
          /*
          dfs(root);
          return ans;
          */
          List<Integer> ret = new ArrayList<Integer>();
          Stack<TreeNode> stack = new Stack<TreeNode>();
          if (root == null) {
              return ret;
          }
          stack.push(root);
          while (!stack.isEmpty()) {
              TreeNode node = stack.pop();
              ret.add(node.val);
              // 先序遍历入栈时先如右子树，后入左子树，出栈时才能先出左子树，本质时bfs
              if (node.right != null) {
                  stack.push(node.right);
              }
              if (node.left != null) {
                  stack.push(node.left);
              }
          }
          return ret;
      }

      public void dfs(TreeNode node){
          if (node == null) {
              return;
          }
          ans.add(node.val);
          dfs(node.left);
          dfs(node.right);
      }

  }


2.6.模拟栈的入栈出栈过程
2.6.1.验证栈序列（leetcode [946] Validate Stack Sequences）
  代码：
  class Solution {
      public boolean validateStackSequences(int[] pushed, int[] popped) {
          Stack<Integer> stack = new Stack<Integer>();
          int i = 0, j = 0;
          int len = pushed.length;
          for (; i <= len;) {
              while (!stack.isEmpty() && stack.peek() == popped[j]) {
                  stack.pop();
                  ++j;
              }
              if (i < len) {
                  stack.push(pushed[i]);
              }
              ++i;

          }
          return j==len;

      }
  }
  
2.7.字符串重复字符的删除
2.7.1.删除字符串指定数目的相邻相同字符（leetcode [1209] Remove All Adjacent Duplicates in String II）
  代码：
  class Solution {
    public String removeDuplicates(String s, int k) {
        Stack<Character> stack = new Stack<Character>();
        HashMap<Character, Stack<Integer>> map = new HashMap<Character, Stack<Integer>>();
        for (char c : s.toCharArray()) {
            if (stack.isEmpty()) {
                stack.push(c);
                if (!map.containsKey(c)) {
                    Stack<Integer> sk = new Stack<Integer>();
                    map.put(c, sk);
                }
                map.get(c).push(1);
            } else {
                if (c == stack.peek()) {
                    if (map.get(c).peek() == k-1) {
                        int cnt = k - 1;
                        while(cnt > 0) {
                            stack.pop();
                            --cnt;
                        }
                        map.get(c).pop();
                    } else {
                        stack.push(c);
                        // map.put(c, map.get(c).pop() + 1);
                        map.get(c).push(map.get(c).pop() + 1);
                    }
                } else {
                    stack.push(c);
                    if (!map.containsKey(c)) {
                        Stack<Integer> sk = new Stack<Integer>();
                        map.put(c, sk);
                    }
                    map.get(c).push(1);
                }

            }
        }
        String ans = new String("");
        while(!stack.isEmpty()) {
            ans = stack.pop() + ans;
        }
        return ans;
    }
}




