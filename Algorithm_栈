1.参考
1.1.http://fanqieto.top/2018/09/04/LeetCode-%E6%A0%88%E7%B1%BB%E7%AE%97%E6%B3%95%E7%B2%BE%E6%9E%90/
1.2.https://blog.csdn.net/koudaidai/article/details/7571521
1.3.https://my.oschina.net/brianway/blog/1545142

2.实际问题
2.1.括号类
2.1.1.删除最外层的括号(leetcode [1021] Remove Outermost Parentheses)
  关键：判断栈是否为空找到最外层的括号位置；动态记录最外层括号包裹的子字符串
  代码：
  class Solution {
      public String removeOuterParentheses(String S) {
          StringBuilder ans = new StringBuilder("");
          Stack<Character> stack = new Stack<Character>();
          int start = 0;
          boolean flag = false;
          for (int i = 0; i < S.length(); ++i) {
              if (S.charAt(i) == '(') {
                  stack.push('(');
                  if (!flag) {
                      start = i;
                      flag = true;
                  } 
              } else {
                  char c = stack.pop();
                  if (stack.isEmpty()) {
                      ans.append(S.substring(start+1, i));
                      flag = false;
                  }
              }
          }
          return ans.toString();
      }
  }
  
2.2.单调栈
2.2.1.寻找一个数组每个元素在它右边出现的第一个大于它的数(leetcode [496] Next Greater Element I)
  代码：
  class Solution {
      public int[] nextGreaterElement(int[] nums1, int[] nums2) {
          HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
          Stack<Integer> stack = new Stack<Integer> ();
          int[] ans = new int[nums1.length];
          for (int num : nums2) {
              if (stack.isEmpty()) {
                  stack.push(num);
              } else {
                  // 单调栈是严格单调递减的
                  while (!stack.isEmpty() && stack.peek() < num) {
                      map.put(stack.pop(), num);
                  }
                  stack.push(num);
              }
          }
          while (!stack.isEmpty()) {
              map.put(stack.pop(), -1);
          }
          for (int i = 0; i < nums1.length; ++i) {
              ans[i] = map.get(nums1[i]);
          }
          return ans;
      }
  }
  2.2.2.循环寻找一个数组每个元素在它右边出现的第一个大于它的数（leetcode 503. Next Greater Element II）
    代码：
    class Solution {
        public int[] nextGreaterElements(int[] nums) {
            int[] ans = new int[nums.length];
            boolean[] flag = new boolean[nums.length];
            Stack<Integer> stack = new Stack<Integer>();
            for (int i = 0; i < nums.length; ++i) {
                if (i == 0) {
                    stack.push(0);
                } else {
                    while(!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
                        int t = stack.pop();
                        ans[t] = nums[i];
                        flag[t] = true;
                    }
                    stack.push(i);
                }
            }
            for (int i = 0; i < nums.length; ++i) {
                if (stack.isEmpty()) {
                    break;
                } else {
                    while(!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
                        int t = stack.pop();
                        ans[t] = nums[i];
                        flag[t] = true;
                    }
                    if (!flag[i]) {
                        stack.push(i);
                    }                
                }
            }
            for (int i = 0; i < nums.length; ++i) {
                if (!flag[i]) {
                    ans[i] = -1;
                }
            }
            return ans;
        }
    }

