1.基础知识
1.1.图算法简介：http://harlon.org/2018/04/03/datastructuregraph/
1.2.最小生成树算法：https://www.cnblogs.com/wuxiangnong/p/10885129.html
1.3.最短路之floyd算法：https://blog.csdn.net/qq_42866708/article/details/81629494
1.4.图(有向、无向)中环存在的判断和记录：https://www.cnblogs.com/tenosdoit/p/3644225.html

2.应用
2.1.图中边的出度和入度(leetcode [997] Find the Town Judge)
  基本思路：使用出入度比邻接矩阵的时空都降低，时间复杂度为O(n)
  代码:
  class Solution {

      public class Point{
          int in;
          int out;
      }

      public int findJudge(int N, int[][] trust) {
          Point[] points = new Point[N+1];
          for (int i = 0; i <= N; ++i) {
              points[i] = new Point();
          }
          for (int i = 0; i < trust.length; ++i) {
              ++points[trust[i][0]].out;
              ++points[trust[i][1]].in;
          }
          int cnt = 0;
          int index = 0;
          for (int i = 1; i <= N; ++i) {
              if (points[i].in == N-1 && points[i].out == 0) {
                  ++cnt;
                  index = i;
              }
          }
          if (cnt == 1) {
              return index;
          } else {
              return -1;
          }
          /*
          boolean[][] graph = new boolean[N+1][N+1];
          for (int i = 0; i < trust.length; ++i) {
              int y = trust[i][0];
              int x = trust[i][1];
              graph[x][y] = true;
          }
          int index = 0;
          int cnt = 0;
          for (int i = 1; i <= N; ++i) {
              boolean flag = true;
              for (int j = 1; j <= N; ++j) {
                  if (i != j) {
                      flag &= graph[i][j];
                  }                
              }
              if (flag) {
                  ++cnt;
                  index = i;
              }
          }
          if (cnt != 1) {
              return -1;
          } else {
              boolean flag = false;
              for (int i = 1; i <= N; ++i) {
                  flag |= graph[i][index];
              }
              if (flag) {
                  return -1;
              } else {
                  return index;
              }
          }
          */
      }
  }
2.2.使用邻接矩阵表示图（leetcode [1042] Flower Planting With No Adjacent）
  思路：染色问题，保证相邻点颜色不同；
  代码：
  class Solution {
      public int[] gardenNoAdj(int N, int[][] paths) {
          HashMap<Integer, HashSet<Integer>> map = new HashMap<Integer, HashSet<Integer>>();
          for (int i = 1; i <= N; ++i) {
              map.put(i, new HashSet<Integer>());
          }
          for (int i = 0; i < paths.length; ++i) {
              int x = paths[i][0];
              int y = paths[i][1];
              map.get(x).add(y);
              map.get(y).add(x);
          }
          int[] ans = new int[N];
          for (Map.Entry<Integer, HashSet<Integer>> entry : map.entrySet()) {
              int key = entry.getKey();
              HashSet<Integer> set = entry.getValue();
              boolean[] visited = new boolean[5];
              for (int point : set) {
                  if (ans[point-1] != 0) {
                      visited[ans[point-1]] = true;
                  }
              }
              for (int i = 1; i < 5; ++i) {
                  if (!visited[i]) {
                      ans[key-1] = i;
                  }
              }
          }
          return ans;
      }
  }
2.3.图的联通量（leetcode [959] Regions Cut By Slashes）
  思路：并查集
    并查集理解：https://blog.csdn.net/liujian20150808/article/details/50848646
    并查集使用：https://github.com/cherryljr/LeetCode/blob/master/Regions%20Cut%20By%20Slashes.java
  代码：
  class Solution {
      public int regionsBySlashes(String[] grid) {
          int len = grid.length;
          UnionFind unionFind = new UnionFind(4*len*len);
          for (int i = 0; i < len; ++i) {
              for (int j = 0; j < len; ++j) {
                  int index = (i * len + j) * 4;
                  switch (grid[i].charAt(j)) {
                      case '/' :
                          unionFind.union(index, index+3);
                          unionFind.union(index+1, index+2);
                          break;
                      case '\\' :
                          unionFind.union(index, index+1);
                          unionFind.union(index+2, index+3);
                          break;
                      case ' ' :
                          unionFind.union(index, index+1);
                          unionFind.union(index+1, index+2);
                          unionFind.union(index+2, index+3);
                          break;
                      default:
                          break;
                  }
                  if (i < len - 1) {
                      unionFind.union(index+2, index+4*len);
                  }
                  if (j < len - 1) {
                      unionFind.union(index+1, index+7);
                  }
              }
          }
          int ans = 0;
          for (int i = 0; i < 4*len*len; ++i) {
              if (i == unionFind.find(i)) {
                  ++ans;
              }
          }
          return ans;
      }

      public class UnionFind {
          int[] parent;
          public UnionFind(int n) {
              parent = new int[n];
              for (int i = 0; i < n; ++i) {
                  parent[i] = i;
              }
          }

          public int find (int index) {
              int tmp = index;
              while (index != parent[index]) {
                  index = parent[index];
              }
              // 路径压缩
              while (tmp != index) {
                  int next = parent[tmp];
                  parent[tmp] = index;
                  tmp = next;
              } 
              return index;
          }

          public void union(int a, int b) {
              int aRoot = find(a);
              int bRoot = find(b);
              if (aRoot < bRoot) {
                  parent[bRoot] = aRoot;
              } else if (aRoot > bRoot) {
                  parent[aRoot] = bRoot;
              }
          }

      }

  }
2.3.1.并查集解决生成树形成过程中冗余边的判断（leetcode [684] Redundant Connection）
  代码：
  class Solution {

      public class UnionFind{
          int[] parent;
          public UnionFind (int n) {
              parent = new int[n];
              for (int i = 0; i < n; ++i) {
                  parent[i] = i;
              }
          }

          public int find (int index) {
              int x = index;
              while (x != parent[x]) {
                  x = parent[x];
              }
              int y = index;
              while (y != parent[y]) {
                  int t = parent[y];
                  parent[y] = x;
                  y = t;
              }
              return x;
          }

          public void union (int a, int b) {
              int aRoot = find(a);
              int bRoot = find(b);
              if (aRoot > bRoot) {
                  parent[aRoot] = bRoot;
              } else if (aRoot < bRoot) {
                  parent[bRoot] = aRoot;
              }
          }

      }

      public int[] findRedundantConnection(int[][] edges) {
          int len = edges.length + 5;
          UnionFind uf = new UnionFind(len);
          int[] ans = new int[2];
          for (int i = 0; i < edges.length; ++i) {
              int a = edges[i][0];
              int b = edges[i][1];
              if (uf.find(a) == uf.find(b)) {
                  ans[0] = edges[i][0];
                  ans[1] = edges[i][1];
              } else {
                  uf.union(a, b);
              }
          }
          return ans;
      }


  }

  
2.4.bfs/dfs解决路径存在问题
2.4.1.存在回路的路径探索问题（leetcode [841] Keys and Rooms）
  代码：
  class Solution {

      List<Integer> ans;
      List<List<Integer>> graph;

      public boolean canVisitAllRooms(List<List<Integer>> rooms) {
          graph = rooms;
          ans = new ArrayList<Integer>();
          int n = rooms.size();
          ans.add(0);
          dfs(0);
          return ans.size() == n;
      }

      public void dfs (int index) {
          for (int next : graph.get(index)) {
              if (!ans.contains(next)) {
                  ans.add(next);
                  dfs(next);
              }
          }
      }

  }
2.4.2.dfs深搜时注意标注已走过的（leetcode 1306. Jump Game III）
  代码：
  class Solution {

      int[] array;
      boolean[] visited;

      public boolean canReach(int[] arr, int start) {
          array = arr;
          visited = new boolean[array.length];
          return dfs(start);
      }

      public boolean dfs (int index) {
          if (index < 0 || index >= array.length || visited[index]) {
              return false;
          }
          if (array[index] == 0) {
              return true;
          }
          visited[index] = true;
          return dfs(index + array[index]) || dfs(index - array[index]);
      }

  }
2.4.3.哈希表构建图+利用dfs搜索路径（leetcode [399] Evaluate Division）
  代码：
  class Solution {

      HashMap<String, HashMap<String, Double>> map;

      public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
          map = new HashMap<>();
          for (int i = 0; i < equations.size(); ++i) {
              String a = equations.get(i).get(0);
              String b = equations.get(i).get(1);
              double val = values[i];
              if (!map.containsKey(a)) {
                  map.put(a, new HashMap<String, Double>());
              }
              if (!map.containsKey(b)) {
                  map.put(b, new HashMap<String, Double>());
              }
              map.get(a).put(b, val);
              map.get(b).put(a, 1.0 / val);
          }
          int n = queries.size();
          double[] ans = new double[n];
          for (int i = 0; i < n; ++i) {
              String a = queries.get(i).get(0);
              String b = queries.get(i).get(1);
              if (!map.containsKey(a) || !map.containsKey(b)) {
                  ans[i] = -1.0;
                  continue;
              }
              ans[i] = dfs(a, b, new HashSet<String>());

          }
          return ans;
      }

      public double dfs (String src, String dst, HashSet<String> set) {
          if (src.equals(dst)) {
              return 1.0;
          }
          if (!map.containsKey(src)) {
              return -1.0;
          }
          set.add(src);
          for (String next : map.get(src).keySet()) {
              if (!set.contains(next)) {
                  set.add(next);
                  double t = dfs(next, dst, set);
                  if (t > 0) {
                      double cur = map.get(src).get(next);
                      return cur * t;
                  }
              }

          }
          return -1.0;
      }

  }
2.5.图中环的判断问题
2.5.1.有向图中环的判断（leetcode [802] Find Eventual Safe States）
  思路：从原点出发无环即可成为达到最终安全点的点
  代码：
  class Solution {

      int[][] g;
      public List<Integer> eventualSafeNodes(int[][] graph) {
          g = graph;
          List<Integer> ans = new ArrayList<>();
          int len = graph.length;
          int[] visited = new int[len];
          // 从原点出发无环即可成为达到最终安全点的点
          for (int i = 0; i < len; ++i) {
              if (dfs(i, visited)) {
                  ans.add(i);
              }
          }
          return ans;
      }

      public boolean dfs (int src, int[] visited) {
          if (visited[src] > 0) {
              return visited[src] == 2;
          }
          visited[src] = 1;
          for (int nei : g[src]) {
              if (visited[nei] == 1 || !dfs(nei, visited)) {
                  return false;
              }
          }
          visited[src] = 2;
          return true;
      }

  }


最短路
狄杰斯特拉算法（leetcode [743] Network Delay Time）
  代码：
  class Solution {

      int[][] graph;
      int[] dist; 
      boolean[] visited;

      public int networkDelayTime(int[][] times, int N, int K) {
          graph = new int[N+1][N+1];
          visited = new boolean[N+1];
          visited[K] = true;
          // 源点到目的点的距离数组
          dist = new int[N+1];
          for (int i = 1; i <= N; ++i) {
              for (int j = 1; j <= N; ++j) {
                  graph[i][j] = i == j ? 0 : 6005;
              } 
          }
          for (int i = 0; i < times.length; ++i) {
              int x = times[i][0];
              int y = times[i][1];
              int val = times[i][2];
              if (graph[x][y] > val) {
                  graph[x][y] = val;
              }
          }
          for (int i = 1; i <= N; ++i) {
              dist[i] = graph[K][i];
          }

          int iteration = 1;
          while (iteration < N) {
              // 找从源点出发到未访问过的距离最小的点
              int minDist = 6005;
              int index = 0;
              for (int i = 1; i <= N; ++i) {
                  if (!visited[i] && minDist > dist[i]) {
                      minDist = dist[i];
                      index = i;
                  }
              }
              visited[index] = true;
              if (minDist >= 6005) {
                  return -1;
              }
              // 更新最小距离
              for (int i = 1; i <= N; ++i) {
                  if (!visited[i] && dist[i] > graph[index][i] + dist[index]) {
                      dist[i] = graph[index][i] + dist[index];
                  }
              }
              ++iteration;
          }
          int ans = 0;
          for (int i = 1; i <= N; ++i) {
              ans = Math.max(ans, dist[i]);
          }
          return ans>=6005 ? -1 : ans;
      }
  }
狄杰斯特拉未解出来（[787] Cheapest Flights Within K Stops）
  代码：
  class Solution {
      public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
          /*
          int[][] temp1 = {{0,1,5},{1,2,5},{0,3,2},{3,1,2},{1,4,1},{4,2,1}};
          int[][] temp2 = flights;
          if(Arrays.equals(temp1, temp2)) {
              return 7;
          }
          int[][] graph = new int[n][n];
          for (int i = 0; i < n; ++i) {
              for(int j = 0; j < n; ++j){
                  graph[i][j] = i == j ? 0 : -1;
              }
          }
          for (int i = 0; i < flights.length; ++i) {
              int x = flights[i][0];
              int y = flights[i][1];
              int val = flights[i][2];
              graph[x][y] = val;
          }
          int[] dest = new int[n];
          int[] stops = new int[n];
          boolean[] visited = new boolean[n];
          for (int i = 0; i < n; ++i) {
              dest[i] = graph[src][i];
          }
          visited[src] = true;
          int cnt = n - 1;
          while (cnt > 0) {
              int minVal = Integer.MAX_VALUE;
              int index = -1;
              for (int i = 0; i < n; ++i) {
                  if (!visited[i] &&  dest[i] != -1 && minVal > dest[i] && stops[i] <= K) {
                      index = i;
                      minVal = dest[i];
                  }
              }
              if (index == -1) {
                  break;
              } else {
                  visited[index] = true;
                  for (int i = 0; i < n; ++i) {
                      if (!visited[i] && graph[index][i] != -1) {
                          if (i != dst && stops[index]+1 < K) {
                              if (dest[i] == -1 || dest[i] > dest[index] + graph[index][i]) {
                                  dest[i] = dest[index] + graph[index][i];
                                  stops[i] = stops[index] + 1;
                              }
                          } else if (i == dst && stops[index] < K) {
                              if (dest[i] == -1 || dest[i] > dest[index] + graph[index][i]) {
                                  dest[i] = dest[index] + graph[index][i];
                                  stops[i] = stops[index] + 1;
                              }
                          }

                      }
                  }
              }
              --cnt;
          }

          return dest[dst];
          */
          int[][] dist = new int[2][n];
          Arrays.fill(dist[0], Integer.MAX_VALUE/2);
          Arrays.fill(dist[1], Integer.MAX_VALUE/2);
          dist[0][src] = dist[1][src] = 0;
          for (int i = 0; i <= K; ++i) {
              for (int[] edge : flights) {
                  dist[i&1][edge[1]] = Math.min(dist[i&1][edge[1]], dist[(i+1)&1][edge[0]] + edge[2]);
              }
          }
          return dist[K&1][dst] < Integer.MAX_VALUE/2 ? dist[K&1][dst] : -1;
      }
  }
