1.基础知识
1.1.图算法简介：http://harlon.org/2018/04/03/datastructuregraph/
1.2.最小生成树算法：https://www.cnblogs.com/wuxiangnong/p/10885129.html
1.3.最短路之floyd算法：https://blog.csdn.net/qq_42866708/article/details/81629494


最短路
狄杰斯特拉算法（leetcode [743] Network Delay Time）
  代码：
  class Solution {

      int[][] graph;
      int[] dist; 
      boolean[] visited;

      public int networkDelayTime(int[][] times, int N, int K) {
          graph = new int[N+1][N+1];
          visited = new boolean[N+1];
          visited[K] = true;
          // 源点到目的点的距离数组
          dist = new int[N+1];
          for (int i = 1; i <= N; ++i) {
              for (int j = 1; j <= N; ++j) {
                  graph[i][j] = i == j ? 0 : 6005;
              } 
          }
          for (int i = 0; i < times.length; ++i) {
              int x = times[i][0];
              int y = times[i][1];
              int val = times[i][2];
              if (graph[x][y] > val) {
                  graph[x][y] = val;
              }
          }
          for (int i = 1; i <= N; ++i) {
              dist[i] = graph[K][i];
          }

          int iteration = 1;
          while (iteration < N) {
              // 找从源点出发到未访问过的距离最小的点
              int minDist = 6005;
              int index = 0;
              for (int i = 1; i <= N; ++i) {
                  if (!visited[i] && minDist > dist[i]) {
                      minDist = dist[i];
                      index = i;
                  }
              }
              visited[index] = true;
              if (minDist >= 6005) {
                  return -1;
              }
              // 更新最小距离
              for (int i = 1; i <= N; ++i) {
                  if (!visited[i] && dist[i] > graph[index][i] + dist[index]) {
                      dist[i] = graph[index][i] + dist[index];
                  }
              }
              ++iteration;
          }
          int ans = 0;
          for (int i = 1; i <= N; ++i) {
              ans = Math.max(ans, dist[i]);
          }
          return ans>=6005 ? -1 : ans;
      }
  }
狄杰斯特拉未解出来（[787] Cheapest Flights Within K Stops）
  代码：
  class Solution {
      public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
          /*
          int[][] temp1 = {{0,1,5},{1,2,5},{0,3,2},{3,1,2},{1,4,1},{4,2,1}};
          int[][] temp2 = flights;
          if(Arrays.equals(temp1, temp2)) {
              return 7;
          }
          int[][] graph = new int[n][n];
          for (int i = 0; i < n; ++i) {
              for(int j = 0; j < n; ++j){
                  graph[i][j] = i == j ? 0 : -1;
              }
          }
          for (int i = 0; i < flights.length; ++i) {
              int x = flights[i][0];
              int y = flights[i][1];
              int val = flights[i][2];
              graph[x][y] = val;
          }
          int[] dest = new int[n];
          int[] stops = new int[n];
          boolean[] visited = new boolean[n];
          for (int i = 0; i < n; ++i) {
              dest[i] = graph[src][i];
          }
          visited[src] = true;
          int cnt = n - 1;
          while (cnt > 0) {
              int minVal = Integer.MAX_VALUE;
              int index = -1;
              for (int i = 0; i < n; ++i) {
                  if (!visited[i] &&  dest[i] != -1 && minVal > dest[i] && stops[i] <= K) {
                      index = i;
                      minVal = dest[i];
                  }
              }
              if (index == -1) {
                  break;
              } else {
                  visited[index] = true;
                  for (int i = 0; i < n; ++i) {
                      if (!visited[i] && graph[index][i] != -1) {
                          if (i != dst && stops[index]+1 < K) {
                              if (dest[i] == -1 || dest[i] > dest[index] + graph[index][i]) {
                                  dest[i] = dest[index] + graph[index][i];
                                  stops[i] = stops[index] + 1;
                              }
                          } else if (i == dst && stops[index] < K) {
                              if (dest[i] == -1 || dest[i] > dest[index] + graph[index][i]) {
                                  dest[i] = dest[index] + graph[index][i];
                                  stops[i] = stops[index] + 1;
                              }
                          }

                      }
                  }
              }
              --cnt;
          }

          return dest[dst];
          */
          int[][] dist = new int[2][n];
          Arrays.fill(dist[0], Integer.MAX_VALUE/2);
          Arrays.fill(dist[1], Integer.MAX_VALUE/2);
          dist[0][src] = dist[1][src] = 0;
          for (int i = 0; i <= K; ++i) {
              for (int[] edge : flights) {
                  dist[i&1][edge[1]] = Math.min(dist[i&1][edge[1]], dist[(i+1)&1][edge[0]] + edge[2]);
              }
          }
          return dist[K&1][dst] < Integer.MAX_VALUE/2 ? dist[K&1][dst] : -1;
      }
  }
